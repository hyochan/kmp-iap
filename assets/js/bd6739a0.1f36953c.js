"use strict";(self.webpackChunkkmp_iap_docs=self.webpackChunkkmp_iap_docs||[]).push([[1507],{928:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var r=t(4848),i=t(8453);const a={sidebar_position:3,title:"Complete Implementation"},o="Complete Production-Ready Implementation",s={id:"examples/complete-implementation",title:"Complete Implementation",description:"A comprehensive, production-ready implementation with all best practices for a robust in-app purchase system using Kotlin Multiplatform.",source:"@site/versioned_docs/version-1.0.0-beta/examples/complete-implementation.md",sourceDirName:"examples",slug:"/examples/complete-implementation",permalink:"/kmp-iap/docs/1.0.0-beta/examples/complete-implementation",draft:!1,unlisted:!1,editUrl:"https://github.com/hyochan/kmp-iap/tree/main/docs/versioned_docs/version-1.0.0-beta/examples/complete-implementation.md",tags:[],version:"1.0.0-beta",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Complete Implementation"},sidebar:"docsSidebar",previous:{title:"Subscription Store",permalink:"/kmp-iap/docs/1.0.0-beta/examples/subscription-store"}},c={},l=[{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"Complete Store Implementation",id:"complete-store-implementation",level:2},{value:"1. IAP Service",id:"1-iap-service",level:3},{value:"2. Store ViewModel",id:"2-store-viewmodel",level:3},{value:"3. Store UI (Compose)",id:"3-store-ui-compose",level:3},{value:"4. Configuration &amp; Security",id:"4-configuration--security",level:3},{value:"5. Dependency Injection Setup",id:"5-dependency-injection-setup",level:3},{value:"6. Local Cache Implementation",id:"6-local-cache-implementation",level:3},{value:"Security Best Practices",id:"security-best-practices",level:2},{value:"Production Considerations",id:"production-considerations",level:2},{value:"Error Handling &amp; Recovery",id:"error-handling--recovery",level:3},{value:"Analytics Integration",id:"analytics-integration",level:3},{value:"Testing Strategy",id:"testing-strategy",level:3},{value:"Platform-Specific Considerations",id:"platform-specific-considerations",level:2},{value:"iOS",id:"ios",level:3},{value:"Android",id:"android",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h1,{id:"complete-production-ready-implementation",children:"Complete Production-Ready Implementation"}),"\n",(0,r.jsx)(e.p,{children:"A comprehensive, production-ready implementation with all best practices for a robust in-app purchase system using Kotlin Multiplatform."}),"\n",(0,r.jsx)(e.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,r.jsx)(e.p,{children:"This implementation includes:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"State management with ViewModel and StateFlow"}),"\n",(0,r.jsx)(e.li,{children:"Server-side receipt validation"}),"\n",(0,r.jsx)(e.li,{children:"Offline support with local caching"}),"\n",(0,r.jsx)(e.li,{children:"Comprehensive error handling"}),"\n",(0,r.jsx)(e.li,{children:"Analytics tracking"}),"\n",(0,r.jsx)(e.li,{children:"Security best practices"}),"\n",(0,r.jsx)(e.li,{children:"Dependency injection with Koin"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"complete-store-implementation",children:"Complete Store Implementation"}),"\n",(0,r.jsx)(e.h3,{id:"1-iap-service",children:"1. IAP Service"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:'// services/IAPService.kt\nimport io.github.hyochan.kmpiap.KmpIAP\nimport io.github.hyochan.kmpiap.data.*\nimport io.ktor.client.*\nimport io.ktor.client.request.*\nimport io.ktor.client.statement.*\nimport io.ktor.http.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlinx.serialization.*\nimport kotlinx.serialization.json.*\n\ninterface IAPService {\n    val purchaseUpdates: SharedFlow<PurchaseUpdate>\n    suspend fun initialize(): Boolean\n    suspend fun getProducts(productIds: List<String>): List<Product>\n    suspend fun getSubscriptions(subscriptionIds: List<String>): List<Product>\n    suspend fun purchaseProduct(productId: String)\n    suspend fun purchaseSubscription(productId: String)\n    suspend fun getAvailablePurchases(): List<Purchase>\n    suspend fun restorePurchases()\n    fun dispose()\n}\n\nclass IAPServiceImpl(\n    private val scope: CoroutineScope,\n    private val httpClient: HttpClient,\n    private val authService: AuthService,\n    private val analyticsService: AnalyticsService,\n    private val localCache: LocalCache\n) : IAPService {\n    \n    \n    private val _purchaseUpdates = MutableSharedFlow<PurchaseUpdate>()\n    override val purchaseUpdates: SharedFlow<PurchaseUpdate> = _purchaseUpdates.asSharedFlow()\n    \n    init {\n        observeStates()\n    }\n    \n    override suspend fun initialize(): Boolean {\n        return try {\n            KmpIAP.initConnection()\n            true\n        } catch (e: PurchaseError) {\n            println("IAP initialization failed: ${e.message}")\n            false\n        }\n    }\n    \n    private fun observeStates() {\n        // Observe purchase updates\n        scope.launch {\n            KmpIAP.currentPurchase.collectLatest { purchase ->\n                purchase?.let { handlePurchaseUpdate(it) }\n            }\n        }\n        \n        // Observe errors\n        scope.launch {\n            KmpIAP.purchaseErrorListener.collect { error ->\n                _purchaseUpdates.emit(\n                    PurchaseUpdate(\n                        item = null,\n                        status = PurchaseStatus.ERROR,\n                        error = error.message\n                    )\n                )\n            }\n        }\n    }\n    \n    private suspend fun handlePurchaseUpdate(purchase: Purchase) {\n        try {\n            // Validate receipt server-side\n            val validationResult = validatePurchase(purchase)\n            \n            if (validationResult.isValid) {\n                // Deliver content\n                deliverPurchase(purchase, validationResult)\n                \n                // Complete transaction\n                completeTransaction(purchase)\n                \n                _purchaseUpdates.emit(\n                    PurchaseUpdate(\n                        item = purchase,\n                        status = PurchaseStatus.SUCCESS,\n                        validationResult = validationResult\n                    )\n                )\n                \n                // Clear purchase state\n                KmpIAP.clearPurchase()\n            } else {\n                _purchaseUpdates.emit(\n                    PurchaseUpdate(\n                        item = purchase,\n                        status = PurchaseStatus.VALIDATION_FAILED,\n                        error = "Receipt validation failed"\n                    )\n                )\n            }\n        } catch (e: Exception) {\n            _purchaseUpdates.emit(\n                PurchaseUpdate(\n                    item = purchase,\n                    status = PurchaseStatus.ERROR,\n                    error = e.message\n                )\n            )\n        }\n    }\n    \n    override suspend fun getProducts(productIds: List<String>): List<Product> {\n        return try {\n            KmpIAP.getProducts(productIds)\n        } catch (e: PurchaseError) {\n            println("Failed to get products: ${e.message}")\n            emptyList()\n        }\n    }\n    \n    override suspend fun getSubscriptions(subscriptionIds: List<String>): List<Product> {\n        return try {\n            // In KMP-IAP, subscriptions are also products\n            KmpIAP.getProducts(subscriptionIds)\n        } catch (e: PurchaseError) {\n            println("Failed to get subscriptions: ${e.message}")\n            emptyList()\n        }\n    }\n    \n    override suspend fun purchaseProduct(productId: String) {\n        KmpIAP.requestPurchase(\n            sku = productId\n        )\n    }\n    \n    override suspend fun purchaseSubscription(productId: String) {\n        KmpIAP.requestPurchase(sku = productId)\n    }\n    \n    override suspend fun getAvailablePurchases(): List<Purchase> {\n        return KmpIAP.availablePurchases.value\n    }\n    \n    override suspend fun restorePurchases() {\n        // Purchases are automatically restored via availablePurchases StateFlow\n        val purchases = getAvailablePurchases()\n        \n        // Re-validate and deliver non-consumable purchases\n        purchases.forEach { purchase ->\n            if (!isConsumableProduct(purchase.productId)) {\n                val validationResult = validatePurchase(purchase)\n                if (validationResult.isValid) {\n                    deliverPurchase(purchase, validationResult)\n                }\n            }\n        }\n    }\n    \n    private suspend fun validatePurchase(purchase: Purchase): ValidationResult {\n        return try {\n            val platform = when {\n                Platform.isIOS -> "ios"\n                Platform.isAndroid -> "android"\n                else -> "unknown"\n            }\n            \n            val response = httpClient.post("${Config.BASE_URL}/api/validate-purchase") {\n                contentType(ContentType.Application.Json)\n                bearerAuth(authService.getToken())\n                setBody(\n                    ValidationRequest(\n                        platform = platform,\n                        productId = purchase.productId,\n                        transactionId = purchase.transactionId,\n                        receipt = purchase.transactionReceipt,\n                        userId = authService.getCurrentUserId()\n                    )\n                )\n            }\n            \n            if (response.status == HttpStatusCode.OK) {\n                val data: ValidationResponse = response.body()\n                ValidationResult.Valid(data.purchaseData)\n            } else {\n                ValidationResult.Invalid("Server validation failed")\n            }\n        } catch (e: Exception) {\n            ValidationResult.Invalid(e.message ?: "Validation error")\n        }\n    }\n    \n    private suspend fun deliverPurchase(\n        purchase: Purchase,\n        validationResult: ValidationResult\n    ) {\n        // Update local storage\n        localCache.savePurchase(purchase)\n        \n        // Track analytics\n        analyticsService.trackPurchase(purchase)\n        \n        // Grant content/features based on product ID\n        when (purchase.productId) {\n            "coins_100" -> localCache.addCoins(100)\n            "coins_500" -> localCache.addCoins(500)\n            "remove_ads" -> localCache.setPremiumFeature("ads_removed", true)\n            "premium_upgrade" -> localCache.setPremiumFeature("premium", true)\n            "premium_monthly", "premium_yearly" -> {\n                localCache.setActiveSubscription(\n                    productId = purchase.productId,\n                    purchaseData = validationResult.purchaseData\n                )\n            }\n        }\n    }\n    \n    private suspend fun completeTransaction(purchase: Purchase) {\n        val isConsumable = isConsumableProduct(purchase.productId)\n        \n        val success = KmpIAP.finishTransaction(\n            purchase = purchase,\n            isConsumable = isConsumable\n        )\n        \n        if (success) {\n            println("Transaction completed: ${purchase.productId}")\n        } else {\n            println("Failed to complete transaction: ${purchase.productId}")\n        }\n    }\n    \n    private fun isConsumableProduct(productId: String): Boolean {\n        return ProductConfig.isConsumable(productId)\n    }\n    \n    override fun dispose() {\n        KmpIAP.dispose()\n    }\n}\n\n// Data models\ndata class PurchaseUpdate(\n    val item: Purchase?,\n    val status: PurchaseStatus,\n    val error: String? = null,\n    val validationResult: ValidationResult? = null\n)\n\nenum class PurchaseStatus {\n    SUCCESS,\n    ERROR,\n    VALIDATION_FAILED,\n    CANCELLED\n}\n\nsealed class ValidationResult {\n    abstract val purchaseData: Map<String, Any>?\n    abstract val isValid: Boolean\n    \n    data class Valid(\n        override val purchaseData: Map<String, Any>\n    ) : ValidationResult() {\n        override val isValid = true\n    }\n    \n    data class Invalid(\n        val error: String\n    ) : ValidationResult() {\n        override val purchaseData = null\n        override val isValid = false\n    }\n}\n\n@Serializable\ndata class ValidationRequest(\n    val platform: String,\n    val productId: String,\n    val transactionId: String?,\n    val receipt: String?,\n    val userId: String\n)\n\n@Serializable\ndata class ValidationResponse(\n    val isValid: Boolean,\n    val purchaseData: Map<String, JsonElement>\n)\n'})}),"\n",(0,r.jsx)(e.h3,{id:"2-store-viewmodel",children:"2. Store ViewModel"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:'// viewmodels/StoreViewModel.kt\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.launch\nimport org.koin.core.component.KoinComponent\nimport org.koin.core.component.inject\n\nclass StoreViewModel : ViewModel(), KoinComponent {\n    private val iapService: IAPService by inject()\n    private val localCache: LocalCache by inject()\n    \n    data class StoreState(\n        val isInitialized: Boolean = false,\n        val isLoading: Boolean = false,\n        val products: List<Product> = emptyList(),\n        val subscriptions: List<Product> = emptyList(),\n        val purchases: List<Purchase> = emptyList(),\n        val error: String? = null,\n        val selectedTab: Int = 0\n    )\n    \n    private val _state = MutableStateFlow(StoreState())\n    val state: StateFlow<StoreState> = _state.asStateFlow()\n    \n    init {\n        initialize()\n        observePurchaseUpdates()\n    }\n    \n    private fun initialize() {\n        viewModelScope.launch {\n            _state.update { it.copy(isLoading = true) }\n            \n            try {\n                val isInitialized = iapService.initialize()\n                \n                if (isInitialized) {\n                    // Load initial data\n                    loadProducts()\n                    loadPurchases()\n                }\n                \n                _state.update { \n                    it.copy(\n                        isInitialized = isInitialized,\n                        isLoading = false,\n                        error = null\n                    )\n                }\n            } catch (e: Exception) {\n                _state.update { \n                    it.copy(\n                        isLoading = false,\n                        error = e.message\n                    )\n                }\n            }\n        }\n    }\n    \n    private fun observePurchaseUpdates() {\n        viewModelScope.launch {\n            iapService.purchaseUpdates.collectLatest { update ->\n                when (update.status) {\n                    PurchaseStatus.SUCCESS -> {\n                        loadPurchases() // Refresh purchases\n                        showMessage("Purchase successful!")\n                    }\n                    PurchaseStatus.ERROR,\n                    PurchaseStatus.VALIDATION_FAILED -> {\n                        _state.update { it.copy(error = update.error) }\n                    }\n                    PurchaseStatus.CANCELLED -> {\n                        // Handle cancellation silently\n                    }\n                }\n            }\n        }\n    }\n    \n    private suspend fun loadProducts() {\n        try {\n            val productIds = ProductConfig.getAllProductIds()\n            val subscriptionIds = ProductConfig.getAllSubscriptionIds()\n            \n            val products = iapService.getProducts(productIds)\n            val subscriptions = iapService.getSubscriptions(subscriptionIds)\n            \n            _state.update { \n                it.copy(\n                    products = products,\n                    subscriptions = subscriptions\n                )\n            }\n        } catch (e: Exception) {\n            _state.update { it.copy(error = e.message) }\n        }\n    }\n    \n    private suspend fun loadPurchases() {\n        try {\n            val purchases = iapService.getAvailablePurchases()\n            _state.update { it.copy(purchases = purchases) }\n        } catch (e: Exception) {\n            _state.update { it.copy(error = e.message) }\n        }\n    }\n    \n    fun purchaseProduct(productId: String) {\n        viewModelScope.launch {\n            try {\n                _state.update { it.copy(error = null) }\n                iapService.purchaseProduct(productId)\n            } catch (e: Exception) {\n                _state.update { it.copy(error = e.message) }\n            }\n        }\n    }\n    \n    fun purchaseSubscription(productId: String) {\n        viewModelScope.launch {\n            try {\n                _state.update { it.copy(error = null) }\n                iapService.purchaseSubscription(productId)\n            } catch (e: Exception) {\n                _state.update { it.copy(error = e.message) }\n            }\n        }\n    }\n    \n    fun restorePurchases() {\n        viewModelScope.launch {\n            _state.update { it.copy(isLoading = true) }\n            \n            try {\n                iapService.restorePurchases()\n                showMessage("Purchases restored")\n            } catch (e: Exception) {\n                _state.update { it.copy(error = e.message) }\n            } finally {\n                _state.update { it.copy(isLoading = false) }\n            }\n        }\n    }\n    \n    fun isPurchased(productId: String): Boolean {\n        return _state.value.purchases.any { it.productId == productId }\n    }\n    \n    fun isSubscriptionActive(productId: String): Boolean {\n        val purchase = _state.value.purchases.find { it.productId == productId }\n        return purchase != null && isSubscriptionValid(purchase)\n    }\n    \n    private fun isSubscriptionValid(purchase: Purchase): Boolean {\n        // Check cached subscription data\n        val subscriptionData = localCache.getActiveSubscription()\n        return subscriptionData?.productId == purchase.productId &&\n               subscriptionData.isValid()\n    }\n    \n    fun selectTab(index: Int) {\n        _state.update { it.copy(selectedTab = index) }\n    }\n    \n    fun clearError() {\n        _state.update { it.copy(error = null) }\n    }\n    \n    fun retry() {\n        initialize()\n    }\n    \n    private fun showMessage(message: String) {\n        // In a real app, emit to a message channel\n        println("Store: $message")\n    }\n    \n    override fun onCleared() {\n        super.onCleared()\n        iapService.dispose()\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"3-store-ui-compose",children:"3. Store UI (Compose)"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:'// ui/screens/StoreScreen.kt\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.viewmodel.compose.viewModel\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun StoreScreen(\n    viewModel: StoreViewModel = viewModel()\n) {\n    val state by viewModel.state.collectAsState()\n    \n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = { Text("Store") },\n                actions = {\n                    IconButton(\n                        onClick = viewModel::restorePurchases,\n                        enabled = !state.isLoading\n                    ) {\n                        Icon(\n                            Icons.Default.Restore,\n                            contentDescription = "Restore Purchases"\n                        )\n                    }\n                }\n            )\n        }\n    ) { paddingValues ->\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(paddingValues)\n        ) {\n            when {\n                !state.isInitialized -> {\n                    InitializingView()\n                }\n                state.isLoading && state.products.isEmpty() -> {\n                    LoadingView()\n                }\n                state.error != null && state.products.isEmpty() -> {\n                    ErrorView(\n                        error = state.error!!,\n                        onRetry = viewModel::retry\n                    )\n                }\n                else -> {\n                    StoreContent(\n                        state = state,\n                        viewModel = viewModel\n                    )\n                }\n            }\n            \n            // Error snackbar for non-critical errors\n            state.error?.let { error ->\n                if (state.products.isNotEmpty()) {\n                    Snackbar(\n                        modifier = Modifier.align(Alignment.BottomCenter),\n                        action = {\n                            TextButton(onClick = viewModel::clearError) {\n                                Text("Dismiss")\n                            }\n                        }\n                    ) {\n                        Text(error)\n                    }\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun InitializingView() {\n    Box(\n        modifier = Modifier.fillMaxSize(),\n        contentAlignment = Alignment.Center\n    ) {\n        Column(\n            horizontalAlignment = Alignment.CenterHorizontally,\n            verticalArrangement = Arrangement.spacedBy(16.dp)\n        ) {\n            CircularProgressIndicator()\n            Text("Initializing store...")\n        }\n    }\n}\n\n@Composable\nfun LoadingView() {\n    Box(\n        modifier = Modifier.fillMaxSize(),\n        contentAlignment = Alignment.Center\n    ) {\n        CircularProgressIndicator()\n    }\n}\n\n@Composable\nfun ErrorView(\n    error: String,\n    onRetry: () -> Unit\n) {\n    Box(\n        modifier = Modifier.fillMaxSize(),\n        contentAlignment = Alignment.Center\n    ) {\n        Column(\n            horizontalAlignment = Alignment.CenterHorizontally,\n            verticalArrangement = Arrangement.spacedBy(16.dp)\n        ) {\n            Icon(\n                Icons.Default.ErrorOutline,\n                contentDescription = null,\n                modifier = Modifier.size(64.dp),\n                tint = MaterialTheme.colorScheme.error\n            )\n            Text(\n                "Store Error",\n                style = MaterialTheme.typography.headlineSmall\n            )\n            Text(\n                error,\n                style = MaterialTheme.typography.bodyMedium,\n                color = MaterialTheme.colorScheme.onSurfaceVariant\n            )\n            Button(onClick = onRetry) {\n                Text("Retry")\n            }\n        }\n    }\n}\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun StoreContent(\n    state: StoreViewModel.StoreState,\n    viewModel: StoreViewModel\n) {\n    Column(modifier = Modifier.fillMaxSize()) {\n        // Tab bar\n        TabRow(selectedTabIndex = state.selectedTab) {\n            Tab(\n                selected = state.selectedTab == 0,\n                onClick = { viewModel.selectTab(0) },\n                text = { Text("Products") }\n            )\n            Tab(\n                selected = state.selectedTab == 1,\n                onClick = { viewModel.selectTab(1) },\n                text = { Text("Subscriptions") }\n            )\n        }\n        \n        // Tab content\n        when (state.selectedTab) {\n            0 -> ProductsTab(\n                products = state.products,\n                isPurchased = viewModel::isPurchased,\n                onPurchase = viewModel::purchaseProduct\n            )\n            1 -> SubscriptionsTab(\n                subscriptions = state.subscriptions,\n                isActive = viewModel::isSubscriptionActive,\n                onSubscribe = viewModel::purchaseSubscription\n            )\n        }\n    }\n}\n\n@Composable\nfun ProductsTab(\n    products: List<Product>,\n    isPurchased: (String) -> Boolean,\n    onPurchase: (String) -> Unit\n) {\n    if (products.isEmpty()) {\n        EmptyStateView("No products available")\n    } else {\n        LazyColumn(\n            contentPadding = PaddingValues(16.dp),\n            verticalArrangement = Arrangement.spacedBy(12.dp)\n        ) {\n            items(products) { product ->\n                ProductCard(\n                    product = product,\n                    isPurchased = isPurchased(product.productId),\n                    onPurchase = { onPurchase(product.productId) }\n                )\n            }\n        }\n    }\n}\n\n@Composable\nfun SubscriptionsTab(\n    subscriptions: List<Product>,\n    isActive: (String) -> Boolean,\n    onSubscribe: (String) -> Unit\n) {\n    if (subscriptions.isEmpty()) {\n        EmptyStateView("No subscriptions available")\n    } else {\n        LazyColumn(\n            contentPadding = PaddingValues(16.dp),\n            verticalArrangement = Arrangement.spacedBy(12.dp)\n        ) {\n            items(subscriptions) { subscription ->\n                SubscriptionCard(\n                    subscription = subscription,\n                    isActive = isActive(subscription.productId),\n                    onSubscribe = { onSubscribe(subscription.productId) }\n                )\n            }\n        }\n    }\n}\n\n@Composable\nfun ProductCard(\n    product: Product,\n    isPurchased: Boolean,\n    onPurchase: () -> Unit\n) {\n    Card(\n        modifier = Modifier.fillMaxWidth()\n    ) {\n        Row(\n            modifier = Modifier\n                .fillMaxWidth()\n                .padding(16.dp),\n            horizontalArrangement = Arrangement.SpaceBetween,\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            Column(modifier = Modifier.weight(1f)) {\n                Text(\n                    product.title,\n                    style = MaterialTheme.typography.titleMedium\n                )\n                product.description?.let { desc ->\n                    Text(\n                        desc,\n                        style = MaterialTheme.typography.bodySmall,\n                        color = MaterialTheme.colorScheme.onSurfaceVariant\n                    )\n                }\n            }\n            \n            if (isPurchased) {\n                Surface(\n                    shape = MaterialTheme.shapes.small,\n                    color = Color(0xFF4CAF50),\n                    contentColor = Color.White\n                ) {\n                    Text(\n                        "OWNED",\n                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp),\n                        style = MaterialTheme.typography.labelSmall,\n                        fontWeight = FontWeight.Bold\n                    )\n                }\n            } else {\n                Button(onClick = onPurchase) {\n                    Text(product.price)\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun SubscriptionCard(\n    subscription: Product,\n    isActive: Boolean,\n    onSubscribe: () -> Unit\n) {\n    Card(\n        modifier = Modifier.fillMaxWidth(),\n        colors = if (isActive) {\n            CardDefaults.cardColors(\n                containerColor = MaterialTheme.colorScheme.primaryContainer\n            )\n        } else {\n            CardDefaults.cardColors()\n        }\n    ) {\n        Row(\n            modifier = Modifier\n                .fillMaxWidth()\n                .padding(16.dp),\n            horizontalArrangement = Arrangement.SpaceBetween,\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            Column(modifier = Modifier.weight(1f)) {\n                Row(verticalAlignment = Alignment.CenterVertically) {\n                    Text(\n                        subscription.title,\n                        style = MaterialTheme.typography.titleMedium\n                    )\n                    if (isActive) {\n                        Spacer(modifier = Modifier.width(8.dp))\n                        Icon(\n                            Icons.Default.CheckCircle,\n                            contentDescription = null,\n                            modifier = Modifier.size(20.dp),\n                            tint = Color(0xFF4CAF50)\n                        )\n                    }\n                }\n                subscription.description?.let { desc ->\n                    Text(\n                        desc,\n                        style = MaterialTheme.typography.bodySmall,\n                        color = MaterialTheme.colorScheme.onSurfaceVariant\n                    )\n                }\n            }\n            \n            if (isActive) {\n                Surface(\n                    shape = MaterialTheme.shapes.small,\n                    color = MaterialTheme.colorScheme.primary,\n                    contentColor = MaterialTheme.colorScheme.onPrimary\n                ) {\n                    Text(\n                        "ACTIVE",\n                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp),\n                        style = MaterialTheme.typography.labelSmall,\n                        fontWeight = FontWeight.Bold\n                    )\n                }\n            } else {\n                Button(onClick = onSubscribe) {\n                    Text(subscription.price)\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun EmptyStateView(message: String) {\n    Box(\n        modifier = Modifier.fillMaxSize(),\n        contentAlignment = Alignment.Center\n    ) {\n        Text(\n            message,\n            style = MaterialTheme.typography.bodyLarge,\n            color = MaterialTheme.colorScheme.onSurfaceVariant\n        )\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"4-configuration--security",children:"4. Configuration & Security"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:'// config/ProductConfig.kt\nobject ProductConfig {\n    private val products = mapOf(\n        "coins_100" to ProductInfo(type = ProductType.CONSUMABLE, value = 100),\n        "coins_500" to ProductInfo(type = ProductType.CONSUMABLE, value = 500),\n        "remove_ads" to ProductInfo(type = ProductType.NON_CONSUMABLE),\n        "premium_monthly" to ProductInfo(type = ProductType.SUBSCRIPTION),\n        "premium_yearly" to ProductInfo(type = ProductType.SUBSCRIPTION)\n    )\n    \n    fun getAllProductIds(): List<String> {\n        return products.entries\n            .filter { it.value.type != ProductType.SUBSCRIPTION }\n            .map { it.key }\n    }\n    \n    fun getAllSubscriptionIds(): List<String> {\n        return products.entries\n            .filter { it.value.type == ProductType.SUBSCRIPTION }\n            .map { it.key }\n    }\n    \n    fun isConsumable(productId: String): Boolean {\n        return products[productId]?.type == ProductType.CONSUMABLE\n    }\n    \n    fun getProductInfo(productId: String): ProductInfo? {\n        return products[productId]\n    }\n}\n\ndata class ProductInfo(\n    val type: ProductType,\n    val value: Int? = null\n)\n\nenum class ProductType {\n    CONSUMABLE,\n    NON_CONSUMABLE,\n    SUBSCRIPTION\n}\n\n// config/Config.kt\nobject Config {\n    const val BASE_URL = "https://api.yourapp.com"\n    const val API_KEY = BuildConfig.API_KEY // Store in build config\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"5-dependency-injection-setup",children:"5. Dependency Injection Setup"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:"// di/AppModule.kt\nimport org.koin.androidx.viewmodel.dsl.viewModel\nimport org.koin.dsl.module\nimport io.ktor.client.*\nimport io.ktor.client.engine.*\nimport io.ktor.client.plugins.contentnegotiation.*\nimport io.ktor.serialization.kotlinx.json.*\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\n\nval appModule = module {\n    // Networking\n    single {\n        HttpClient {\n            install(ContentNegotiation) {\n                json()\n            }\n        }\n    }\n    \n    // Coroutine scope for IAP\n    single {\n        CoroutineScope(SupervisorJob() + Dispatchers.Main)\n    }\n    \n    // Services\n    single<AuthService> { AuthServiceImpl() }\n    single<AnalyticsService> { AnalyticsServiceImpl() }\n    single<LocalCache> { LocalCacheImpl(get()) }\n    single<IAPService> { \n        IAPServiceImpl(\n            scope = get(),\n            httpClient = get(),\n            authService = get(),\n            analyticsService = get(),\n            localCache = get()\n        )\n    }\n    \n    // ViewModels\n    viewModel { StoreViewModel() }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"6-local-cache-implementation",children:"6. Local Cache Implementation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:'// cache/LocalCache.kt\nimport com.russhwolf.settings.Settings\nimport kotlinx.serialization.*\nimport kotlinx.serialization.json.*\nimport kotlinx.datetime.*\n\ninterface LocalCache {\n    suspend fun savePurchase(purchase: Purchase)\n    suspend fun getPurchases(): List<Purchase>\n    suspend fun addCoins(amount: Int)\n    suspend fun getCoins(): Int\n    suspend fun setPremiumFeature(feature: String, enabled: Boolean)\n    suspend fun isPremiumFeature(feature: String): Boolean\n    suspend fun setActiveSubscription(productId: String, purchaseData: Map<String, Any>?)\n    suspend fun getActiveSubscription(): SubscriptionData?\n}\n\nclass LocalCacheImpl(\n    private val settings: Settings\n) : LocalCache {\n    \n    private val json = Json { ignoreUnknownKeys = true }\n    \n    override suspend fun savePurchase(purchase: Purchase) {\n        val purchases = getPurchases().toMutableList()\n        purchases.removeAll { it.productId == purchase.productId }\n        purchases.add(purchase)\n        \n        val purchasesJson = json.encodeToString(purchases)\n        settings.putString("purchases", purchasesJson)\n    }\n    \n    override suspend fun getPurchases(): List<Purchase> {\n        val purchasesJson = settings.getStringOrNull("purchases") ?: return emptyList()\n        return try {\n            json.decodeFromString(purchasesJson)\n        } catch (e: Exception) {\n            emptyList()\n        }\n    }\n    \n    override suspend fun addCoins(amount: Int) {\n        val currentCoins = getCoins()\n        settings.putInt("coins", currentCoins + amount)\n    }\n    \n    override suspend fun getCoins(): Int {\n        return settings.getInt("coins", 0)\n    }\n    \n    override suspend fun setPremiumFeature(feature: String, enabled: Boolean) {\n        settings.putBoolean("premium_$feature", enabled)\n    }\n    \n    override suspend fun isPremiumFeature(feature: String): Boolean {\n        return settings.getBoolean("premium_$feature", false)\n    }\n    \n    override suspend fun setActiveSubscription(\n        productId: String, \n        purchaseData: Map<String, Any>?\n    ) {\n        val subscriptionData = SubscriptionData(\n            productId = productId,\n            purchaseTime = Clock.System.now(),\n            purchaseData = purchaseData\n        )\n        \n        val dataJson = json.encodeToString(subscriptionData)\n        settings.putString("active_subscription", dataJson)\n    }\n    \n    override suspend fun getActiveSubscription(): SubscriptionData? {\n        val dataJson = settings.getStringOrNull("active_subscription") ?: return null\n        return try {\n            json.decodeFromString(dataJson)\n        } catch (e: Exception) {\n            null\n        }\n    }\n}\n\n@Serializable\ndata class SubscriptionData(\n    val productId: String,\n    @Serializable(with = InstantSerializer::class)\n    val purchaseTime: Instant,\n    val purchaseData: Map<String, @Contextual Any>?\n) {\n    fun isValid(): Boolean {\n        // Implement subscription expiration logic\n        // This is a simplified check - in production, verify with server\n        val daysSincePurchase = (Clock.System.now() - purchaseTime).inWholeDays\n        \n        return when {\n            productId.contains("monthly") -> daysSincePurchase < 30\n            productId.contains("yearly") -> daysSincePurchase < 365\n            else -> false\n        }\n    }\n}\n\n@Serializer(forClass = Instant::class)\nobject InstantSerializer : KSerializer<Instant> {\n    override val descriptor = PrimitiveSerialDescriptor("Instant", PrimitiveKind.STRING)\n    \n    override fun serialize(encoder: Encoder, value: Instant) {\n        encoder.encodeString(value.toString())\n    }\n    \n    override fun deserialize(decoder: Decoder): Instant {\n        return Instant.parse(decoder.decodeString())\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"security-best-practices",children:"Security Best Practices"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Server-Side Validation"}),": All receipts validated on secure backend"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"User Authentication"}),": Purchases tied to authenticated user accounts"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Secure Storage"}),": Purchase data encrypted using platform secure storage"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Network Security"}),": HTTPS only with certificate pinning"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Code Obfuscation"}),": Use R8/ProGuard for Android, Swift obfuscation for iOS"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"production-considerations",children:"Production Considerations"}),"\n",(0,r.jsx)(e.h3,{id:"error-handling--recovery",children:"Error Handling & Recovery"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:"// Add comprehensive error recovery\nclass ErrorRecoveryHandler {\n    suspend fun handlePurchaseError(error: PurchaseError): RecoveryAction {\n        return when (error.code) {\n            ErrorCode.NETWORK_ERROR -> RecoveryAction.Retry(delay = 2000)\n            ErrorCode.SERVICE_UNAVAILABLE -> RecoveryAction.Retry(delay = 5000)\n            ErrorCode.PRODUCT_ALREADY_OWNED -> RecoveryAction.RestorePurchases\n            else -> RecoveryAction.ShowError(error.message)\n        }\n    }\n}\n\nsealed class RecoveryAction {\n    data class Retry(val delay: Long) : RecoveryAction()\n    object RestorePurchases : RecoveryAction()\n    data class ShowError(val message: String) : RecoveryAction()\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"analytics-integration",children:"Analytics Integration"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:'interface AnalyticsService {\n    fun trackPurchase(purchase: Purchase)\n    fun trackPurchaseError(error: PurchaseError)\n    fun trackRestoreCompleted(count: Int)\n}\n\nclass AnalyticsServiceImpl : AnalyticsService {\n    override fun trackPurchase(purchase: Purchase) {\n        // Track with your analytics provider\n        trackEvent("purchase_completed", mapOf(\n            "product_id" to purchase.productId,\n            "price" to purchase.price,\n            "currency" to purchase.currency\n        ))\n    }\n    \n    override fun trackPurchaseError(error: PurchaseError) {\n        trackEvent("purchase_error", mapOf(\n            "error_code" to error.code.name,\n            "error_message" to error.message\n        ))\n    }\n    \n    override fun trackRestoreCompleted(count: Int) {\n        trackEvent("restore_completed", mapOf(\n            "restored_count" to count\n        ))\n    }\n    \n    private fun trackEvent(name: String, params: Map<String, Any?>) {\n        // Implementation depends on your analytics provider\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"testing-strategy",children:"Testing Strategy"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:'// Create test doubles for IAP testing\nclass MockIAPService : IAPService {\n    private val _purchaseUpdates = MutableSharedFlow<PurchaseUpdate>()\n    override val purchaseUpdates = _purchaseUpdates.asSharedFlow()\n    \n    override suspend fun initialize(): Boolean = true\n    \n    override suspend fun getProducts(productIds: List<String>): List<Product> {\n        return productIds.map { id ->\n            Product(\n                productId = id,\n                title = "Test $id",\n                description = "Test description",\n                price = "$0.99",\n                currency = "USD"\n            )\n        }\n    }\n    \n    // Implement other methods for testing\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"platform-specific-considerations",children:"Platform-Specific Considerations"}),"\n",(0,r.jsx)(e.h3,{id:"ios",children:"iOS"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:"// iOS-specific configuration\nactual class PlatformConfig {\n    actual fun configurePlatform() {\n        // Configure StoreKit\n        if (isDebugBuild()) {\n            // Use StoreKit testing configuration\n            configureStoreKitTesting()\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"android",children:"Android"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:"// Android-specific configuration\nactual class PlatformConfig {\n    actual fun configurePlatform() {\n        // Configure Google Play Billing\n        if (BuildConfig.DEBUG) {\n            // Enable debug logging\n            enableBillingDebugLogging()\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"This implementation provides a robust, production-ready foundation for in-app purchases in Kotlin Multiplatform applications with comprehensive error handling, security, and best practices."})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>s});var r=t(6540);const i={},a=r.createContext(i);function o(n){const e=r.useContext(a);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),r.createElement(a.Provider,{value:e},n.children)}}}]);