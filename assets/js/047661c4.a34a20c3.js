"use strict";(self.webpackChunkkmp_iap_docs=self.webpackChunkkmp_iap_docs||[]).push([[9502],{4335:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var s=r(4848),t=r(8453),i=r(5159);const a={sidebar_position:3,title:"Purchases"},c="Purchases",o={id:"guides/purchases",title:"Purchases",description:"Complete guide to implementing in-app purchases with kmp-iap, covering everything from basic setup to advanced purchase handling using Kotlin Multiplatform.",source:"@site/versioned_docs/version-1.0.0/guides/purchases.md",sourceDirName:"guides",slug:"/guides/purchases",permalink:"/kmp-iap/docs/1.0.0/guides/purchases",draft:!1,unlisted:!1,editUrl:"https://github.com/hyochan/kmp-iap/tree/main/docs/versioned_docs/version-1.0.0/guides/purchases.md",tags:[],version:"1.0.0",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Purchases"},sidebar:"docsSidebar",previous:{title:"Android Setup",permalink:"/kmp-iap/docs/1.0.0/getting-started/android-setup"},next:{title:"Lifecycle",permalink:"/kmp-iap/docs/1.0.0/guides/lifecycle"}},d={},l=[{value:"Purchase Flow Overview",id:"purchase-flow-overview",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Purchase Types",id:"purchase-types",level:3},{value:"Platform Differences",id:"platform-differences",level:3},{value:"Basic Purchase Flow",id:"basic-purchase-flow",level:2},{value:"1. Setup Purchase Observers",id:"1-setup-purchase-observers",level:3},{value:"2. Using with ViewModel (Recommended)",id:"2-using-with-viewmodel-recommended",level:3},{value:"3. Request a Purchase",id:"3-request-a-purchase",level:3},{value:"Product Loading",id:"product-loading",level:2},{value:"Loading Products",id:"loading-products",level:3},{value:"Loading Subscriptions",id:"loading-subscriptions",level:3},{value:"Subscription Purchases",id:"subscription-purchases",level:2},{value:"Subscription Purchase",id:"subscription-purchase",level:3},{value:"Important Notes",id:"important-notes",level:2},{value:"Purchase Flow Best Practices",id:"purchase-flow-best-practices",level:3},{value:"Handling Purchase Success",id:"handling-purchase-success",level:3},{value:"Getting Product Information",id:"getting-product-information",level:2},{value:"Retrieving Product Prices",id:"retrieving-product-prices",level:3},{value:"Platform Support",id:"platform-support",level:3},{value:"Checking Platform Compatibility",id:"checking-platform-compatibility",level:3},{value:"Product Types",id:"product-types",level:2},{value:"Consumable Products",id:"consumable-products",level:3},{value:"Non-Consumable Products",id:"non-consumable-products",level:3},{value:"Subscriptions",id:"subscriptions",level:3},{value:"Advanced Purchase Handling",id:"advanced-purchase-handling",level:2},{value:"Purchase Restoration",id:"purchase-restoration",level:3},{value:"Handling Already Owned Error",id:"handling-already-owned-error",level:3},{value:"Subscription Management",id:"subscription-management",level:3},{value:"Receipt Validation",id:"receipt-validation",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Common Purchase Errors",id:"common-purchase-errors",level:3},{value:"Testing Purchases",id:"testing-purchases",level:2},{value:"iOS Testing",id:"ios-testing",level:3},{value:"Android Testing",id:"android-testing",level:3},{value:"Complete Example",id:"complete-example",level:2},{value:"Compose UI Integration",id:"compose-ui-integration",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"purchases",children:"Purchases"}),"\n",(0,s.jsx)(i.A,{}),"\n",(0,s.jsx)(n.p,{children:"Complete guide to implementing in-app purchases with kmp-iap, covering everything from basic setup to advanced purchase handling using Kotlin Multiplatform."}),"\n",(0,s.jsx)(n.h2,{id:"purchase-flow-overview",children:"Purchase Flow Overview"}),"\n",(0,s.jsx)(n.p,{children:"The in-app purchase flow follows this standardized pattern:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Initialize Connection"})," - Establish connection with the store"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Setup State Observers"})," - Monitor purchase states via StateFlow"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Load Products"})," - Fetch product information from the store"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Request Purchase"})," - Initiate purchase flow"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handle Updates"})," - Process purchase results via StateFlow"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Deliver Content"})," - Provide purchased content to user"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Finish Transaction"})," - Complete the transaction with the store"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"purchase-types",children:"Purchase Types"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consumable"}),": Can be purchased multiple times (coins, gems, lives)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Non-Consumable"}),": Purchased once, owned forever (premium features, ad removal)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Subscriptions"}),": Recurring purchases with auto-renewal"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"platform-differences",children:"Platform Differences"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"iOS"}),": Uses StoreKit 2 (iOS 15.0+)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Android"}),": Uses Google Play Billing Client v8"]}),"\n",(0,s.jsx)(n.li,{children:"Both platforms use the same API surface in kmp-iap"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"basic-purchase-flow",children:"Basic Purchase Flow"}),"\n",(0,s.jsx)(n.h3,{id:"1-setup-purchase-observers",children:"1. Setup Purchase Observers"}),"\n",(0,s.jsx)(n.p,{children:"Before making any purchases, set up StateFlow observers to handle purchase updates and errors:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport io.github.hyochan.kmpiap.KmpIAP\nimport io.github.hyochan.kmpiap.data.*\n\nclass PurchaseHandler(\n    private val scope: CoroutineScope\n) {\n    \n    fun setupPurchaseObservers() {\n        // Observe successful purchases\n        scope.launch {\n            kmpIapInstance.purchaseUpdatedListener.collectLatest { purchase ->\n                println("Purchase update received: ${purchase.productId}")\n                handlePurchaseUpdate(purchase)\n            }\n        }\n\n        // Observe purchase errors\n        scope.launch {\n            kmpIapInstance.purchaseErrorListener.collectLatest { error ->\n                println("Purchase failed: ${error.message}")\n                handlePurchaseError(error)\n            }\n        }\n    }\n    \n    fun dispose() {\n        kmpIapInstance.endConnection()\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-using-with-viewmodel-recommended",children:"2. Using with ViewModel (Recommended)"}),"\n",(0,s.jsx)(n.p,{children:"For a more structured approach, use this purchase handler pattern:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\n\nclass ProductsViewModel : ViewModel() {\n    private val productIds = listOf(\n        "dev.hyo.martie.10bulbs",\n        "dev.hyo.martie.30bulbs"\n    )\n    \n    \n    data class PurchaseState(\n        val isProcessing: Boolean = false,\n        val purchaseResult: String? = null,\n        val products: List<Product> = emptyList()\n    )\n\n\n    private val _state = MutableStateFlow(PurchaseState())\n    val state: StateFlow<PurchaseState> = _state.asStateFlow()\n\n    init {\n        setupPurchaseObservers()\n\n        // Initialize connection and load products\n        viewModelScope.launch {\n            kmpIapInstance.initConnection()\n            loadProducts()\n        }\n    }\n    \n    override fun onCleared() {\n        super.onCleared()\n        kmpIap.dispose()\n    }\n    \n    // Purchase observer setup...\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-request-a-purchase",children:"3. Request a Purchase"}),"\n",(0,s.jsx)(n.p,{children:"Use the unified API for initiating purchases:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'suspend fun handlePurchase(productId: String) {\n    try {\n        _state.update { \n            it.copy(\n                isProcessing = true,\n                purchaseResult = "Processing purchase..."\n            )\n        }\n\n        // Request purchase\n        kmpIapInstance.requestPurchase {\n            ios {\n                sku = productId\n                quantity = 1\n            }\n            android {\n                skus = listOf(productId)\n                obfuscatedAccountIdAndroid = getUserId()\n            }\n        }\n        \n        // Result will be emitted via currentPurchase StateFlow\n    } catch (error: PurchaseError) {\n        _state.update {\n            it.copy(\n                isProcessing = false,\n                purchaseResult = "\u274c Purchase failed: ${error.message}"\n            )\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"product-loading",children:"Product Loading"}),"\n",(0,s.jsx)(n.h3,{id:"loading-products",children:"Loading Products"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'suspend fun loadProducts() {\n    try {\n        // Load products\n        val products = kmpIapInstance.fetchProducts {\n            skus = productIds\n            type = ProductQueryType.InApp\n        }\n\n        println("Loaded ${products.size} products")\n        products.forEach { product ->\n            println("Product: ${product.productId}")\n            println("Price: ${product.price}")\n            println("Title: ${product.title}")\n        }\n\n        _state.update { it.copy(products = products) }\n    } catch (e: PurchaseError) {\n        println("Error loading products: $e")\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loading-subscriptions",children:"Loading Subscriptions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'suspend fun loadSubscriptions() {\n    try {\n        val subscriptionIds = listOf("premium_monthly", "premium_yearly")\n        val subscriptions = kmpIapInstance.fetchProducts {\n            skus = subscriptionIds\n            type = ProductQueryType.Subscription\n        }\n\n        subscriptions.forEach { sub ->\n            println("Subscription: ${sub.title}")\n            println("Price: ${sub.price}")\n            println("Period: ${sub.subscriptionPeriod}")\n        }\n    } catch (e: PurchaseError) {\n        println("Error loading subscriptions: $e")\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"subscription-purchases",children:"Subscription Purchases"}),"\n",(0,s.jsx)(n.h3,{id:"subscription-purchase",children:"Subscription Purchase"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"suspend fun requestSubscription(productId: String) {\n    try {\n        kmpIapInstance.requestPurchase {\n            ios {\n                sku = productId\n                quantity = 1\n            }\n            android {\n                skus = listOf(productId)\n                obfuscatedAccountIdAndroid = getUserId()\n            }\n        }\n        // Result via purchaseUpdatedListener Flow\n    } catch (e: PurchaseError) {\n        handleError(e)\n    }\n}\n\n// With subscription offers (Android)\nsuspend fun requestSubscriptionWithOffer(\n    productId: String,\n    offerToken: String\n) {\n    kmpIapInstance.requestPurchase {\n        ios {\n            sku = productId\n            quantity = 1\n        }\n        android {\n            skus = listOf(productId)\n            subscriptionOffers = listOf(\n                SubscriptionOfferAndroid(\n                    sku = productId,\n                    offerToken = offerToken\n                )\n            )\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"important-notes",children:"Important Notes"}),"\n",(0,s.jsx)(n.h3,{id:"purchase-flow-best-practices",children:"Purchase Flow Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Always set up observers first"})," before making any purchase requests"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handle both success and error cases"})," appropriately"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Show loading states"})," during purchase processing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validate purchases server-side"})," for security"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Finish transactions"})," after delivering content"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"handling-purchase-success",children:"Handling Purchase Success"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'private suspend fun handlePurchaseUpdate(purchase: Purchase) {\n    println("Purchase successful: ${purchase.productId}")\n    \n    // Deliver the product to the user\n    deliverProduct(purchase.productId)\n    \n    // Finish the transaction\n    try {\n        val success = kmpIapInstance.finishTransaction(\n            purchase = purchase.toPurchaseInput(),\n            isConsumable = true // Set appropriately for your product type\n        )\n\n        if (success) {\n            println("Transaction completed successfully")\n        }\n    } catch (e: Exception) {\n        println("Error finishing transaction: $e")\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"getting-product-information",children:"Getting Product Information"}),"\n",(0,s.jsx)(n.h3,{id:"retrieving-product-prices",children:"Retrieving Product Prices"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'class ProductInfo {\n    suspend fun loadProductInformation(productIds: List<String>): List<Product> {\n        return try {\n            // Request products from store\n            val products = kmpIapInstance.fetchProducts {\n                skus = productIds\n                type = ProductQueryType.InApp\n            }\n\n            products.forEach { product ->\n                println("Product: ${product.productId}")\n                println("Title: ${product.title}")\n                println("Description: ${product.description}")\n                println("Price: ${product.price}")\n                println("Currency: ${product.currencyCode}")\n                println("Price Micros: ${product.priceAmountMicros}")\n            }\n\n            products\n        } catch (e: PurchaseError) {\n            println("Error loading product information: $e")\n            emptyList()\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"platform-support",children:"Platform Support"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'import io.github.hyochan.kmpiap.openiap.IapPlatform\n\nclass PlatformSupport {\n    suspend fun checkPurchaseSupport(): Boolean {\n        return try {\n            when (kmpIapInstance.getCurrentPlatform()) {\n                IapPlatform.Ios -> {\n                    // Check if device can make payments\n                    kmpIapInstance.initConnection()\n                    true\n                }\n                IapPlatform.Android -> {\n                    // Check Play Store connection\n                    kmpIapInstance.initConnection()\n                    true\n                }\n            }\n        } catch (e: PurchaseError) {\n            println("Error checking purchase support: $e")\n            false\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"checking-platform-compatibility",children:"Checking Platform Compatibility"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'fun checkPlatformFeatures() {\n    when (kmpIapInstance.getCurrentPlatform()) {\n        IapPlatform.Ios -> {\n            // iOS-specific features\n            println("iOS platform detected")\n            // Can use iOS-specific methods like:\n            // - kmpIapInstance.presentCodeRedemptionSheetIOS()\n            // - kmpIapInstance.showManageSubscriptionsIOS()\n            // - kmpIapInstance.getStorefrontIOS()\n        }\n        IapPlatform.Android -> {\n            // Android-specific features\n            println("Android platform detected")\n            // Can use Android-specific methods like:\n            // - kmpIapInstance.consumePurchase()\n            // - kmpIapInstance.deepLinkToSubscriptionsAndroid()\n            // - kmpIapInstance.requestPurchaseHistoryAndroid()\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"product-types",children:"Product Types"}),"\n",(0,s.jsx)(n.h3,{id:"consumable-products",children:"Consumable Products"}),"\n",(0,s.jsx)(n.p,{children:"Products that can be purchased multiple times:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'suspend fun handleConsumableProduct(purchase: Purchase) {\n    // Deliver the consumable content (coins, lives, etc.)\n    deliverConsumableProduct(purchase.productId)\n\n    // Finish transaction as consumable\n    val success = kmpIapInstance.finishTransaction(\n        purchase = purchase.toPurchaseInput(),\n        isConsumable = true\n    )\n\n    if (success) {\n        println("Consumable product delivered and consumed")\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"non-consumable-products",children:"Non-Consumable Products"}),"\n",(0,s.jsx)(n.p,{children:"Products purchased once and owned permanently:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'suspend fun handleNonConsumableProduct(purchase: Purchase) {\n    // Deliver the permanent content (premium features, ad removal)\n    deliverPermanentProduct(purchase.productId)\n\n    // Finish transaction as non-consumable\n    val success = kmpIapInstance.finishTransaction(\n        purchase = purchase.toPurchaseInput(),\n        isConsumable = false\n    )\n\n    if (success) {\n        println("Non-consumable product delivered")\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"subscriptions",children:"Subscriptions"}),"\n",(0,s.jsx)(n.p,{children:"Recurring purchases with auto-renewal:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'suspend fun handleSubscriptionProduct(purchase: Purchase) {\n    // Activate subscription for user\n    activateSubscription(purchase.productId)\n\n    // Finish transaction as non-consumable\n    val success = kmpIapInstance.finishTransaction(\n        purchase = purchase.toPurchaseInput(),\n        isConsumable = false\n    )\n\n    if (success) {\n        println("Subscription activated")\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-purchase-handling",children:"Advanced Purchase Handling"}),"\n",(0,s.jsx)(n.h3,{id:"purchase-restoration",children:"Purchase Restoration"}),"\n",(0,s.jsx)(n.p,{children:"Restore previously purchased items:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'suspend fun restorePurchases() {\n    try {\n        // Get available purchases\n        val purchases = kmpIapInstance.getAvailablePurchases()\n        println("Found ${purchases.size} available purchases")\n\n        // Process each restored purchase\n        purchases.forEach { purchase ->\n            deliverProduct(purchase.productId)\n        }\n    } catch (e: PurchaseError) {\n        println("Error restoring purchases: $e")\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"handling-already-owned-error",children:"Handling Already Owned Error"}),"\n",(0,s.jsx)(n.p,{children:"Handle cases where user already owns the item:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'private fun handlePurchaseError(error: PurchaseError) {\n    println("Purchase failed: ${error.message}")\n\n    when (error.code) {\n        ErrorCode.AlreadyOwned -> {\n            println("User already owns this item")\n            scope.launch {\n                // Refresh available purchases\n                kmpIapInstance.getAvailablePurchases()\n            }\n        }\n        ErrorCode.UserCancelled -> {\n            // User cancelled, no action needed\n            println("Purchase cancelled by user")\n        }\n        else -> {\n            // Handle other errors\n            showErrorDialog(error.message)\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"subscription-management",children:"Subscription Management"}),"\n",(0,s.jsx)(n.p,{children:"Open native subscription management:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'suspend fun openSubscriptionManagement() {\n    try {\n        when (kmpIapInstance.getCurrentPlatform()) {\n            IapPlatform.Ios -> {\n                kmpIapInstance.showManageSubscriptionsIOS()\n            }\n            IapPlatform.Android -> {\n                kmpIapInstance.deepLinkToSubscriptionsAndroid("premium_monthly")\n            }\n        }\n    } catch (e: PurchaseError) {\n        println("Failed to open subscription management: $e")\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"receipt-validation",children:"Receipt Validation"}),"\n",(0,s.jsx)(n.p,{children:"Validate purchases server-side for security:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'suspend fun validatePurchaseReceipt(purchase: Purchase): Boolean {\n    return try {\n        // Send to your server for validation\n        val response = api.validatePurchase(\n            productId = purchase.productId,\n            purchaseToken = purchase.purchaseToken,\n            receipt = purchase.transactionReceipt,\n            platform = kmpIapInstance.getCurrentPlatform().name\n        )\n\n        response.isValid\n    } catch (e: Exception) {\n        println("Receipt validation failed: $e")\n        false\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.h3,{id:"common-purchase-errors",children:"Common Purchase Errors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'fun handlePurchaseError(error: PurchaseError) {\n    when (error.code) {\n        ErrorCode.UserCancelled -> {\n            println("User cancelled the purchase")\n        }\n        ErrorCode.NetworkError -> {\n            println("Network error occurred")\n            showRetryDialog()\n        }\n        ErrorCode.ServiceUnavailable -> {\n            println("Billing service unavailable")\n        }\n        ErrorCode.ProductNotAvailable -> {\n            println("Requested item is unavailable")\n        }\n        ErrorCode.DeveloperError -> {\n            println("Invalid arguments provided to the API")\n        }\n        ErrorCode.AlreadyOwned -> {\n            println("User already owns this item")\n            handleAlreadyOwned()\n        }\n        ErrorCode.Unknown -> {\n            println("Unknown error: ${error.message}")\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing-purchases",children:"Testing Purchases"}),"\n",(0,s.jsx)(n.h3,{id:"ios-testing",children:"iOS Testing"}),"\n",(0,s.jsx)(n.p,{children:"Set up iOS testing environment:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'// For iOS testing in sandbox environment\nfun setupIOSTesting() {\n    println("Testing on iOS Sandbox")\n    \n    // Use test Apple ID for sandbox testing\n    // Products must be configured in App Store Connect\n    // Test with different sandbox user accounts\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"android-testing",children:"Android Testing"}),"\n",(0,s.jsx)(n.p,{children:"Set up Android testing environment:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'// For Android testing with test purchases\nfun setupAndroidTesting() {\n    println("Testing on Android")\n    \n    // Use test product IDs like:\n    // - android.test.purchased\n    // - android.test.canceled  \n    // - android.test.refunded\n    // - android.test.item_unavailable\n    \n    val testProductIds = listOf(\n        "android.test.purchased", // Always succeeds\n        "android.test.canceled"   // Always cancelled\n    )\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"complete-example",children:"Complete Example"}),"\n",(0,s.jsx)(n.p,{children:"Here's a complete working example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport io.github.hyochan.kmpiap.useIap.*\nimport io.github.hyochan.kmpiap.data.*\n\nclass PurchaseService : ViewModel() {\n    init {\n        // Initialize IAP connection\n        viewModelScope.launch {\n            kmpIapInstance.initConnection()\n        }\n    \n    init {\n        setupPurchaseObservers()\n    }\n    \n    private fun setupPurchaseObservers() {\n        // Observe purchase success\n        viewModelScope.launch {\n            kmpIapInstance.purchaseUpdatedListener.collectLatest { purchase ->\n                handlePurchaseSuccess(purchase)\n            }\n        }\n\n        // Observe errors\n        viewModelScope.launch {\n            kmpIapInstance.purchaseErrorListener.collectLatest { error ->\n                handlePurchaseError(error)\n            }\n        }\n    }\n    \n    private suspend fun handlePurchaseSuccess(purchase: Purchase) {\n        // 1. Deliver product\n        deliverProduct(purchase.productId)\n\n        // 2. Finish transaction\n        val success = kmpIapInstance.finishTransaction(\n            purchase = purchase.toPurchaseInput(),\n            isConsumable = true\n        )\n\n        if (success) {\n            println("Transaction completed")\n        }\n    }\n    \n    private fun handlePurchaseError(error: PurchaseError) {\n        if (error.code == ErrorCode.AlreadyOwned) {\n            // Handle "already owned" error\n            viewModelScope.launch {\n                kmpIapInstance.getAvailablePurchases()\n            }\n        }\n    }\n    \n    suspend fun purchaseProduct(productId: String) {\n        kmpIapInstance.requestPurchase {\n            ios {\n                sku = productId\n                quantity = 1\n            }\n            android {\n                skus = listOf(productId)\n                obfuscatedAccountIdAndroid = getUserId()\n            }\n        }\n    }\n    \n    override fun onCleared() {\n        super.onCleared()\n        kmpIapInstance.endConnection()\n    }\n\n    private fun deliverProduct(productId: String) {\n        // Implement your product delivery logic\n    }\n    \n    private fun getUserId(): String {\n        // Return user ID for fraud prevention\n        return "user_123"\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"compose-ui-integration",children:"Compose UI Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'@Composable\nfun PurchaseScreen(viewModel: PurchaseService = viewModel()) {\n    var products by remember { mutableStateOf<List<Product>>(emptyList()) }\n    var isConnected by remember { mutableStateOf(false) }\n    \n    Column {\n        // Connection indicator\n        if (!isConnected) {\n            Card(\n                backgroundColor = Color.Red,\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text("Store not connected", color = Color.White)\n            }\n        }\n        \n        // Products list\n        LazyColumn {\n            items(products) { product ->\n                ProductCard(\n                    product = product,\n                    onPurchase = {\n                        scope.launch {\n                            viewModel.purchaseProduct(product.productId)\n                        }\n                    }\n                )\n            }\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This guide covers the complete purchase flow using the kmp-iap API, with examples demonstrating the Kotlin Multiplatform approach to in-app purchases."})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},5159:(e,n,r)=>{r.d(n,{A:()=>a});r(6540);var s=r(6025),t=r(7856),i=r(4848);function a({className:e="iapkit-banner",style:n}){const r=(0,s.A)("/img/iapkit-banner.gif");return(0,i.jsx)("div",{className:e,style:n,children:(0,i.jsx)("a",{href:t.V,target:"_blank",rel:"noopener noreferrer",onClick:async()=>{try{await fetch(t.I,{method:"POST",mode:"no-cors"})}catch(e){console.error("Failed to track banner click:",e)}},style:{display:"block",textAlign:"center",marginBottom:"20px",textDecoration:"none",cursor:"pointer"},children:(0,i.jsx)("img",{src:r,alt:"IAPKit - In-App Purchase Made Simple",style:{height:"auto",borderRadius:"8px",objectFit:"contain"}})})})}},7856:(e,n,r)=>{r.d(n,{I:()=>t,V:()=>s});const s="https://iapkit.com",t="https://www.hyo.dev/api/ad-banner/cmjf0l20n0002249hjrwmgob3"},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>c});var s=r(6540);const t={},i=s.createContext(t);function a(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);