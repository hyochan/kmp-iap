"use strict";(self.webpackChunkkmp_iap_docs=self.webpackChunkkmp_iap_docs||[]).push([[7482],{1437:(e,n,i)=>{i.d(n,{A:()=>t});i(6540);var s=i(7856),r=i(4848);function t({children:e,href:n,className:i,style:t}){return(0,r.jsx)("a",{href:n||s.V,target:"_blank",rel:"noopener noreferrer",onClick:async()=>{try{await fetch(s.I,{method:"POST",mode:"no-cors"})}catch(e){console.error("Failed to track link click:",e)}},className:i,style:t,children:e})}},5159:(e,n,i)=>{i.d(n,{A:()=>a});i(6540);var s=i(6025),r=i(7856),t=i(4848);function a({className:e="iapkit-banner",style:n}){const i=(0,s.A)("/img/iapkit-banner.gif");return(0,t.jsx)("div",{className:e,style:n,children:(0,t.jsx)("a",{href:r.V,target:"_blank",rel:"noopener noreferrer",onClick:async()=>{try{await fetch(r.I,{method:"POST",mode:"no-cors"})}catch(e){console.error("Failed to track banner click:",e)}},style:{display:"block",textAlign:"center",marginBottom:"20px",textDecoration:"none",cursor:"pointer"},children:(0,t.jsx)("img",{src:i,alt:"IAPKit - In-App Purchase Made Simple",style:{height:"auto",borderRadius:"8px",objectFit:"contain"}})})})}},7856:(e,n,i)=>{i.d(n,{I:()=>r,V:()=>s});const s="https://iapkit.com",r="https://www.hyo.dev/api/ad-banner/cmjf0l20n0002249hjrwmgob3"},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>c});var s=i(6540);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}},9137:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>l,toc:()=>u});var s=i(4848),r=i(8453),t=i(5159),a=i(1437);const c={sidebar_position:6,title:"Subscription Validation"},o="Subscription Validation",l={id:"guides/subscription-validation",title:"Subscription Validation",description:"This guide covers subscription validation best practices, including renewal detection differences between iOS and Android.",source:"@site/docs/guides/subscription-validation.md",sourceDirName:"guides",slug:"/guides/subscription-validation",permalink:"/kmp-iap/docs/guides/subscription-validation",draft:!1,unlisted:!1,editUrl:"https://github.com/hyochan/kmp-iap/tree/main/docs/docs/guides/subscription-validation.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"Subscription Validation"}},d={},u=[{value:"Subscription Renewal Detection",id:"subscription-renewal-detection",level:2},{value:"Platform Differences",id:"platform-differences",level:3},{value:"iOS Behavior",id:"ios-behavior",level:3},{value:"Android Behavior",id:"android-behavior",level:3},{value:"Solution: Server-Side Verification with IAPKit",id:"solution-server-side-verification-with-iapkit",level:3},{value:"Android basePlanId Limitation",id:"android-baseplanid-limitation",level:2},{value:"Solutions",id:"solutions",level:3},{value:"1. Client-side Tracking (Recommended for most apps)",id:"1-client-side-tracking-recommended-for-most-apps",level:4},{value:"2. IAPKit Backend Validation (Recommended)",id:"2-iapkit-backend-validation-recommended",level:4},{value:"3. Single Base Plan Per Subscription Group",id:"3-single-base-plan-per-subscription-group",level:4},{value:"IAPKit Purchase States",id:"iapkit-purchase-states",level:2},{value:"useSubscriptionStatus Hook Pattern",id:"usesubscriptionstatus-hook-pattern",level:2},{value:"Usage in Compose",id:"usage-in-compose",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Check on App Launch",id:"1-check-on-app-launch",level:3},{value:"2. Periodic Validation",id:"2-periodic-validation",level:3},{value:"3. Handle Network Failures Gracefully",id:"3-handle-network-failures-gracefully",level:3},{value:"4. Cache Subscription Status Locally",id:"4-cache-subscription-status-locally",level:3},{value:"Next Steps",id:"next-steps",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"subscription-validation",children:"Subscription Validation"}),"\n",(0,s.jsx)(t.A,{}),"\n",(0,s.jsx)(n.p,{children:"This guide covers subscription validation best practices, including renewal detection differences between iOS and Android."}),"\n",(0,s.jsx)(n.h2,{id:"subscription-renewal-detection",children:"Subscription Renewal Detection"}),"\n",(0,s.jsx)(n.p,{children:"One of the most critical aspects of subscription management is properly detecting subscription renewals, especially when they occur while your app is not running."}),"\n",(0,s.jsx)(n.h3,{id:"platform-differences",children:"Platform Differences"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Aspect"}),(0,s.jsx)(n.th,{children:"iOS (StoreKit 2)"}),(0,s.jsx)(n.th,{children:"Android (Google Play Billing)"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Renewal during app use"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"purchaseUpdatedListener"})," fires"]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"purchaseUpdatedListener"})," fires"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Renewal while app closed"})}),(0,s.jsx)(n.td,{children:"Automatically detected on app launch"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.strong,{children:"Not detected"})," via listener"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Recommended approach"})}),(0,s.jsx)(n.td,{children:"Listener + periodic checks"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"getAvailablePurchases()"})," + server verification"]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"ios-behavior",children:"iOS Behavior"}),"\n",(0,s.jsx)(n.p,{children:"On iOS with StoreKit 2, subscription renewals are automatically detected:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"// Renewals that occurred while app was closed are automatically\n// delivered through the purchaseUpdatedListener on app launch\nkmpIapInstance.purchaseUpdatedListener.collect { purchase ->\n    // This will fire for renewals even if app was closed\n    handleSubscriptionUpdate(purchase)\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"android-behavior",children:"Android Behavior"}),"\n",(0,s.jsxs)(n.p,{children:["On Android, the ",(0,s.jsx)(n.code,{children:"purchaseUpdatedListener"})," does ",(0,s.jsx)(n.strong,{children:"not"})," fire for renewals that occurred while the app was closed. This is a fundamental limitation of Google Play Billing Library."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"// WARNING: This will NOT fire for renewals that happened while app was closed\nkmpIapInstance.purchaseUpdatedListener.collect { purchase ->\n    // Only fires for purchases/renewals while app is running\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"solution-server-side-verification-with-iapkit",children:"Solution: Server-Side Verification with IAPKit"}),"\n",(0,s.jsxs)(n.p,{children:["The recommended approach for both platforms is to verify subscription status on app launch using ",(0,s.jsx)(a.A,{children:"IAPKit"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"suspend fun checkSubscriptionStatusOnAppLaunch() {\n    try {\n        val purchases = kmpIapInstance.getAvailablePurchases()\n\n        purchases.forEach { purchase ->\n            if (isSubscriptionProduct(purchase.productId)) {\n                verifyAndUpdateSubscriptionStatus(purchase)\n            }\n        }\n    } catch (e: Exception) {\n        // Handle error - consider granting temporary access\n        // to avoid penalizing users for network issues\n    }\n}\n\nprivate suspend fun verifyAndUpdateSubscriptionStatus(purchase: Purchase) {\n    val result = kmpIapInstance.verifyPurchaseWithProvider(\n        VerifyPurchaseWithProviderProps(\n            provider = PurchaseVerificationProvider.Iapkit,\n            iapkit = RequestVerifyPurchaseWithIapkitProps(\n                apiKey = AppConfig.iapkitApiKey,\n                apple = RequestVerifyPurchaseWithIapkitAppleProps(\n                    jws = purchase.purchaseToken\n                ),\n                google = RequestVerifyPurchaseWithIapkitGoogleProps(\n                    purchaseToken = purchase.purchaseToken\n                )\n            )\n        )\n    )\n\n    when (result.iapkit?.state) {\n        IapkitPurchaseState.Entitled -> {\n            // Subscription is active - grant/maintain access\n            grantSubscriptionAccess(purchase.productId)\n        }\n        IapkitPurchaseState.Expired -> {\n            // Subscription has expired - revoke access\n            revokeSubscriptionAccess(purchase.productId)\n        }\n        IapkitPurchaseState.Canceled -> {\n            // User canceled but may still have access until period ends\n            // Check expiration date if available\n            handleCanceledSubscription(purchase)\n        }\n        IapkitPurchaseState.Inauthentic -> {\n            // Fraudulent purchase detected\n            revokeSubscriptionAccess(purchase.productId)\n            logSecurityEvent(purchase)\n        }\n        else -> {\n            // Handle unknown states gracefully\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"android-baseplanid-limitation",children:"Android basePlanId Limitation"}),"\n",(0,s.jsx)(n.admonition,{title:"Critical Limitation",type:"warning",children:(0,s.jsxs)(n.p,{children:["On Android, the ",(0,s.jsx)(n.code,{children:"basePlanId"})," field may return ",(0,s.jsx)(n.strong,{children:"incorrect values"})," for subscription groups with multiple base plans."]})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Root Cause:"})," Google Play Billing API's ",(0,s.jsx)(n.code,{children:"Purchase"})," object does NOT include ",(0,s.jsx)(n.code,{children:"basePlanId"})," information. When a subscription group has multiple base plans (weekly, monthly, yearly), there is no way to determine which specific plan was purchased from the client-side ",(0,s.jsx)(n.code,{children:"Purchase"})," object."]}),"\n",(0,s.jsx)(n.p,{children:"You may see this warning in logs:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Multiple offers (3) found for premium_subscription, using first basePlanId (may be inaccurate)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What Works Correctly:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"productId"})," - Subscription group ID"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"purchaseToken"})," - Purchase token"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isActive"})," - Subscription active status"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"transactionId"})," - Transaction ID"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What May Be Incorrect:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"basePlanIdAndroid"})," - May return first plan instead of purchased plan"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"solutions",children:"Solutions"}),"\n",(0,s.jsx)(n.h4,{id:"1-client-side-tracking-recommended-for-most-apps",children:"1. Client-side Tracking (Recommended for most apps)"}),"\n",(0,s.jsxs)(n.p,{children:["Track ",(0,s.jsx)(n.code,{children:"basePlanId"})," yourself during the purchase flow:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"// Track basePlanId BEFORE calling requestPurchase\nvar purchasedBasePlanId: String? = null\n\nsuspend fun handlePurchase(basePlanId: String) {\n    val product = subscriptions.find { it.productId == subscriptionGroupId }\n    if (product !is ProductSubscriptionAndroid) return\n\n    // Use cross-platform subscriptionOffers\n    val offers = product.subscriptionOffers\n    val offer = offers.find {\n        it.basePlanIdAndroid == basePlanId && it.id == null\n    }\n\n    if (offer?.offerTokenAndroid == null) return\n\n    // Store it before purchase\n    purchasedBasePlanId = basePlanId\n\n    kmpIapInstance.requestPurchase {\n        apple { sku = subscriptionGroupId }\n        google {\n            skus = listOf(subscriptionGroupId)\n            subscriptionOffers = listOf(\n                SubscriptionOfferAndroid(\n                    sku = subscriptionGroupId,\n                    offerToken = offer.offerTokenAndroid!!\n                )\n            )\n        }\n    }\n}\n\n// Use YOUR tracked value in purchase listener\nkmpIapInstance.purchaseUpdatedListener.collect { purchase ->\n    // DON'T rely on purchase data for basePlanId - it may be wrong!\n    val actualBasePlanId = purchasedBasePlanId\n\n    saveToBackend(\n        purchaseToken = purchase.purchaseToken,\n        basePlanId = actualBasePlanId,  // Use YOUR tracked value\n        productId = purchase.productId\n    )\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"2-iapkit-backend-validation-recommended",children:"2. IAPKit Backend Validation (Recommended)"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.a,{href:"../apis#verifypurchasewithprovider",children:(0,s.jsx)(n.code,{children:"verifyPurchaseWithProvider"})})," with ",(0,s.jsx)(a.A,{children:"IAPKit"})," to get accurate ",(0,s.jsx)(n.code,{children:"basePlanId"})," from Google Play Developer API:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'val result = kmpIapInstance.verifyPurchaseWithProvider(\n    VerifyPurchaseWithProviderProps(\n        provider = PurchaseVerificationProvider.Iapkit,\n        iapkit = RequestVerifyPurchaseWithIapkitProps(\n            apiKey = AppConfig.iapkitApiKey,\n            google = RequestVerifyPurchaseWithIapkitGoogleProps(\n                purchaseToken = purchase.purchaseToken\n            )\n        )\n    )\n)\n\n// Access basePlanId from the response\nval providerResponse = result.providerResponse as? Map<*, *>\nval lineItems = providerResponse?.get("lineItems") as? List<*>\nval firstItem = lineItems?.firstOrNull() as? Map<*, *>\nval offerDetails = firstItem?.get("offerDetails") as? Map<*, *>\nval basePlanId = offerDetails?.get("basePlanId") as? String\n\nprintln("Actual basePlanId: $basePlanId")\n'})}),"\n",(0,s.jsx)(n.h4,{id:"3-single-base-plan-per-subscription-group",children:"3. Single Base Plan Per Subscription Group"}),"\n",(0,s.jsxs)(n.p,{children:["If your subscription group has only one base plan, the ",(0,s.jsx)(n.code,{children:"basePlanId"})," will always be accurate. This is the simplest solution if your product design allows it."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["This is a fundamental limitation of Google Play Billing API, not a bug in this library. The ",(0,s.jsx)(n.code,{children:"Purchase"})," object from Google simply does not include ",(0,s.jsx)(n.code,{children:"basePlanId"})," information."]})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"See also:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"../api/types#subscriptionoffer",children:"SubscriptionOffer"})," - Each offer contains ",(0,s.jsx)(n.code,{children:"id"}),", ",(0,s.jsx)(n.code,{children:"displayPrice"}),", ",(0,s.jsx)(n.code,{children:"paymentMode"}),", ",(0,s.jsx)(n.code,{children:"period"}),", ",(0,s.jsx)(n.code,{children:"basePlanIdAndroid"}),", ",(0,s.jsx)(n.code,{children:"offerTokenAndroid"}),", and ",(0,s.jsx)(n.code,{children:"pricingPhasesAndroid"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/kmp-iap/docs/guides/subscription-offers",children:"Subscription Offers Guide"})," - Complete guide on working with subscription offers."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/hyochan/react-native-iap/issues/3096",children:"GitHub Issue #3096"})," - Original discussion about this limitation."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"iapkit-purchase-states",children:"IAPKit Purchase States"}),"\n",(0,s.jsxs)(n.p,{children:["When verifying purchases with ",(0,s.jsx)(a.A,{children:"IAPKit"}),", you'll receive one of these states:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"State"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Recommended Action"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"entitled"})}),(0,s.jsx)(n.td,{children:"Active subscription with valid access"}),(0,s.jsx)(n.td,{children:"Grant/maintain premium features"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"expired"})}),(0,s.jsx)(n.td,{children:"Subscription period has ended"}),(0,s.jsx)(n.td,{children:"Revoke access, show renewal prompt"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"canceled"})}),(0,s.jsx)(n.td,{children:"User canceled but period not ended"}),(0,s.jsx)(n.td,{children:"Maintain access until expiration"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"pending"})}),(0,s.jsx)(n.td,{children:"Purchase is being processed"}),(0,s.jsx)(n.td,{children:"Show pending state, await resolution"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"pending-acknowledgment"})}),(0,s.jsx)(n.td,{children:"Android: needs acknowledgment"}),(0,s.jsxs)(n.td,{children:["Call ",(0,s.jsx)(n.code,{children:"finishTransaction()"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ready-to-consume"})}),(0,s.jsx)(n.td,{children:"Consumable ready for consumption"}),(0,s.jsxs)(n.td,{children:["Process and call ",(0,s.jsx)(n.code,{children:"finishTransaction()"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"consumed"})}),(0,s.jsx)(n.td,{children:"Consumable has been used"}),(0,s.jsx)(n.td,{children:"Already processed"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"inauthentic"})}),(0,s.jsx)(n.td,{children:"Failed verification (potential fraud)"}),(0,s.jsx)(n.td,{children:"Revoke access, log for review"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"usesubscriptionstatus-hook-pattern",children:"useSubscriptionStatus Hook Pattern"}),"\n",(0,s.jsx)(n.p,{children:"For Compose Multiplatform apps, create a reusable hook to manage subscription status:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'class SubscriptionStatusManager(\n    private val subscriptionIds: List<String>\n) {\n    private val _subscriptionStatus = MutableStateFlow<SubscriptionStatus>(SubscriptionStatus.Loading)\n    val subscriptionStatus: StateFlow<SubscriptionStatus> = _subscriptionStatus.asStateFlow()\n\n    sealed class SubscriptionStatus {\n        object Loading : SubscriptionStatus()\n        data class Active(val productId: String, val expiresAt: Long?) : SubscriptionStatus()\n        object Expired : SubscriptionStatus()\n        data class Error(val message: String) : SubscriptionStatus()\n    }\n\n    suspend fun checkStatus() {\n        _subscriptionStatus.value = SubscriptionStatus.Loading\n\n        try {\n            val purchases = kmpIapInstance.getAvailablePurchases()\n            val subscriptionPurchase = purchases.find {\n                subscriptionIds.contains(it.productId)\n            }\n\n            if (subscriptionPurchase == null) {\n                _subscriptionStatus.value = SubscriptionStatus.Expired\n                return\n            }\n\n            val result = kmpIapInstance.verifyPurchaseWithProvider(\n                VerifyPurchaseWithProviderProps(\n                    provider = PurchaseVerificationProvider.Iapkit,\n                    iapkit = RequestVerifyPurchaseWithIapkitProps(\n                        apiKey = AppConfig.iapkitApiKey,\n                        apple = RequestVerifyPurchaseWithIapkitAppleProps(\n                            jws = subscriptionPurchase.purchaseToken\n                        ),\n                        google = RequestVerifyPurchaseWithIapkitGoogleProps(\n                            purchaseToken = subscriptionPurchase.purchaseToken\n                        )\n                    )\n                )\n            )\n\n            _subscriptionStatus.value = when (result.iapkit?.state) {\n                IapkitPurchaseState.Entitled -> SubscriptionStatus.Active(\n                    productId = subscriptionPurchase.productId,\n                    expiresAt = null // Parse from providerResponse if needed\n                )\n                else -> SubscriptionStatus.Expired\n            }\n        } catch (e: Exception) {\n            _subscriptionStatus.value = SubscriptionStatus.Error(e.message ?: "Unknown error")\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"usage-in-compose",children:"Usage in Compose"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"@Composable\nfun SubscriptionScreen(\n    subscriptionManager: SubscriptionStatusManager\n) {\n    val status by subscriptionManager.subscriptionStatus.collectAsState()\n\n    LaunchedEffect(Unit) {\n        subscriptionManager.checkStatus()\n    }\n\n    when (val currentStatus = status) {\n        is SubscriptionStatus.Loading -> {\n            CircularProgressIndicator()\n        }\n        is SubscriptionStatus.Active -> {\n            PremiumContent(productId = currentStatus.productId)\n        }\n        is SubscriptionStatus.Expired -> {\n            SubscriptionOffer()\n        }\n        is SubscriptionStatus.Error -> {\n            ErrorMessage(message = currentStatus.message)\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-check-on-app-launch",children:"1. Check on App Launch"}),"\n",(0,s.jsx)(n.p,{children:"Always verify subscription status when the app launches:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class MainViewModel : ViewModel() {\n    init {\n        viewModelScope.launch {\n            kmpIapInstance.initConnection()\n            checkSubscriptionStatus()\n        }\n    }\n\n    private suspend fun checkSubscriptionStatus() {\n        // Verify with IAPKit to get authoritative status\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-periodic-validation",children:"2. Periodic Validation"}),"\n",(0,s.jsx)(n.p,{children:"For long-running sessions, periodically revalidate:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class SubscriptionValidator {\n    private val validationInterval = 24.hours\n\n    suspend fun startPeriodicValidation() {\n        while (true) {\n            delay(validationInterval)\n            validateActiveSubscriptions()\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-handle-network-failures-gracefully",children:"3. Handle Network Failures Gracefully"}),"\n",(0,s.jsx)(n.p,{children:"Don't revoke access immediately on network failures:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"suspend fun validateWithGracePeriod(purchase: Purchase): Boolean {\n    return try {\n        val result = verifyWithIAPKit(purchase)\n        result.iapkit?.state == IapkitPurchaseState.Entitled\n    } catch (e: NetworkException) {\n        // Grant temporary access on network failure\n        // to avoid penalizing users for connectivity issues\n        true\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-cache-subscription-status-locally",children:"4. Cache Subscription Status Locally"}),"\n",(0,s.jsx)(n.p,{children:"Cache the last known status for offline support:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'class SubscriptionCache(private val prefs: SharedPreferences) {\n    fun cacheStatus(productId: String, isActive: Boolean, validUntil: Long) {\n        prefs.edit {\n            putBoolean("sub_active_$productId", isActive)\n            putLong("sub_valid_until_$productId", validUntil)\n        }\n    }\n\n    fun getCachedStatus(productId: String): CachedStatus? {\n        val isActive = prefs.getBoolean("sub_active_$productId", false)\n        val validUntil = prefs.getLong("sub_valid_until_$productId", 0)\n\n        if (validUntil == 0L) return null\n\n        return CachedStatus(\n            isActive = isActive && System.currentTimeMillis() < validUntil,\n            validUntil = validUntil\n        )\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/kmp-iap/docs/examples/subscription-flow",children:"Subscription Flow"})," - Complete subscription implementation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/kmp-iap/docs/guides/subscription-offers",children:"Subscription Offers"})," - Working with subscription offers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/kmp-iap/docs/examples/purchase-flow",children:"Purchase Flow"})," - One-time purchase handling"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/kmp-iap/docs/api/error-codes",children:"Error Codes"})," - Handle verification errors"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}}}]);