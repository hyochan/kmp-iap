"use strict";(self.webpackChunkkmp_iap_docs=self.webpackChunkkmp_iap_docs||[]).push([[6219],{8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>i});var s=r(6540);const t={},c=s.createContext(t);function a(e){const n=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(c.Provider,{value:n},e.children)}},8984:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>p,frontMatter:()=>c,metadata:()=>i,toc:()=>l});var s=r(4848),t=r(8453);const c={title:"Listeners",sidebar_position:4},a="Listeners",i={id:"api/listeners",title:"Listeners",description:"Event listeners and flow collectors for monitoring purchase updates, errors, and connection states in kmp-iap.",source:"@site/docs/api/listeners.md",sourceDirName:"api",slug:"/api/listeners",permalink:"/kmp-iap/docs/api/listeners",draft:!1,unlisted:!1,editUrl:"https://github.com/hyochan/kmp-iap/tree/main/docs/docs/api/listeners.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Listeners",sidebar_position:4},sidebar:"docsSidebar",previous:{title:"Core Methods",permalink:"/kmp-iap/docs/api/core-methods"},next:{title:"Error Codes",permalink:"/kmp-iap/docs/api/error-codes"}},o={},l=[{value:"Purchase Update Listener",id:"purchase-update-listener",level:2},{value:"purchaseUpdatedListener",id:"purchaseupdatedlistener",level:3},{value:"Error Listener",id:"error-listener",level:2},{value:"purchaseErrorListener",id:"purchaseerrorlistener",level:3},{value:"Connection State Listener",id:"connection-state-listener",level:2},{value:"Connection State",id:"connection-state",level:3},{value:"Platform-Specific Listeners",id:"platform-specific-listeners",level:2},{value:"iOS Promoted Product Listener",id:"ios-promoted-product-listener",level:3},{value:"Android Billing Client State",id:"android-billing-client-state",level:3},{value:"Advanced Listener Patterns",id:"advanced-listener-patterns",level:2},{value:"Combined Listeners",id:"combined-listeners",level:3},{value:"Filtered Listeners",id:"filtered-listeners",level:3},{value:"Debounced Listeners",id:"debounced-listeners",level:3},{value:"Lifecycle-Aware Listeners",id:"lifecycle-aware-listeners",level:2},{value:"Compose Integration",id:"compose-integration",level:3},{value:"Activity/Fragment Integration",id:"activityfragment-integration",level:3},{value:"Error Recovery Strategies",id:"error-recovery-strategies",level:2},{value:"Automatic Retry with Listeners",id:"automatic-retry-with-listeners",level:3},{value:"Testing Listeners",id:"testing-listeners",level:2},{value:"Mock Flow Testing",id:"mock-flow-testing",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"listeners",children:"Listeners"}),"\n",(0,s.jsx)(n.p,{children:"Event listeners and flow collectors for monitoring purchase updates, errors, and connection states in kmp-iap."}),"\n",(0,s.jsx)(n.h2,{id:"purchase-update-listener",children:"Purchase Update Listener"}),"\n",(0,s.jsx)(n.h3,{id:"purchaseupdatedlistener",children:"purchaseUpdatedListener"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"val purchaseUpdatedListener: Flow<Purchase>\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type"}),": ",(0,s.jsx)(n.code,{children:"Flow<Purchase>"}),(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Description"}),": Emits purchase updates when transactions occur",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Emission"}),": Triggered on successful purchase completion"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'import kotlinx.coroutines.flow.collectLatest\n\nclass PurchaseManager {\n    private val kmpIAP = KmpIAP()\n    private val scope = CoroutineScope(Dispatchers.Main)\n    \n    init {\n        scope.launch {\n            kmpIAP.purchaseUpdatedListener.collectLatest { purchase ->\n                println("Purchase updated: \\${purchase.productId}")\n                println("Transaction ID: \\${purchase.transactionId}")\n                println("State: \\${purchase.purchaseState}")\n                \n                // Handle purchase based on state\n                when (purchase.purchaseState) {\n                    PurchaseState.PURCHASED -> {\n                        handleSuccessfulPurchase(purchase)\n                    }\n                    PurchaseState.PENDING -> {\n                        handlePendingPurchase(purchase)\n                    }\n                    else -> {\n                        println("Unexpected purchase state")\n                    }\n                }\n            }\n        }\n    }\n    \n    private suspend fun handleSuccessfulPurchase(purchase: Purchase) {\n        // Validate purchase\n        validatePurchase(purchase)\n        \n        // Grant entitlement\n        grantEntitlement(purchase.productId)\n        \n        // Finish transaction\n        kmpIAP.finishTransaction(purchase, isConsumable = true)\n    }\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"error-listener",children:"Error Listener"}),"\n",(0,s.jsx)(n.h3,{id:"purchaseerrorlistener",children:"purchaseErrorListener"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"val purchaseErrorListener: Flow<PurchaseError>\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type"}),": ",(0,s.jsx)(n.code,{children:"Flow<PurchaseError>"}),(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Description"}),": Emits errors that occur during purchase operations",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Emission"}),": Triggered on any purchase-related error"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'import io.github.hyochan.kmpiap.kmpIapInstance\n\nscope.launch {\n    kmpIapInstance.purchaseErrorListener.collectLatest { error ->\n        println("Purchase error: \\${error.message}")\n        println("Error code: \\${error.code}")\n        \n        when (error.code) {\n            ErrorCode.USER_CANCELLED -> {\n                // User cancelled, no action needed\n                println("User cancelled the purchase")\n            }\n            ErrorCode.NETWORK_ERROR -> {\n                showRetryDialog("Network error. Please check your connection.")\n            }\n            ErrorCode.ITEM_UNAVAILABLE -> {\n                showError("This item is not available in your region.")\n            }\n            ErrorCode.ALREADY_OWNED -> {\n                showInfo("You already own this item.")\n                refreshOwnedPurchases()\n            }\n            else -> {\n                showError("Purchase failed: \\${error.message}")\n            }\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"connection-state-listener",children:"Connection State Listener"}),"\n",(0,s.jsx)(n.h3,{id:"connection-state",children:"Connection State"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"suspend fun isConnected(): Boolean\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type"}),": ",(0,s.jsx)(n.code,{children:"suspend fun"}),(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Description"}),": Check connection state to the store service",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Returns"}),": ",(0,s.jsx)(n.code,{children:"Boolean"})," - true if connected"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'// Check connection state\nscope.launch {\n    val connected = kmpIapInstance.isConnected()\n    if (connected) {\n        enablePurchaseButtons()\n        loadProducts()\n    } else {\n        disablePurchaseButtons()\n        showConnectionError()\n    }\n}\n\n// Connection state with retry\nclass ConnectionManager(private val iap: InAppPurchase) {\n    private var retryCount = 0\n    private val maxRetries = 3\n    \n    init {\n        monitorConnection()\n    }\n    \n    private fun monitorConnection() {\n        scope.launch {\n            kmpIapInstance.isConnected.collectLatest { connected ->\n                if (!connected && retryCount < maxRetries) {\n                    delay(2000 * (retryCount + 1)) // Exponential backoff\n                    retryCount++\n                    try {\n                        kmpIapInstance.initConnection()\n                    } catch (e: Exception) {\n                        println("Retry failed: \\${e.message}")\n                    }\n                } else if (connected) {\n                    retryCount = 0\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"platform-specific-listeners",children:"Platform-Specific Listeners"}),"\n",(0,s.jsx)(n.h3,{id:"ios-promoted-product-listener",children:"iOS Promoted Product Listener"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"val promotedProductIOS: StateFlow<Product?>\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type"}),": ",(0,s.jsx)(n.code,{children:"StateFlow<Product?>"}),(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Platform"}),": iOS only",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Description"}),": Product promoted from App Store that triggered app launch"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"if (getCurrentPlatform() == IapPlatform.IOS) {\n    scope.launch {\n        kmpIapInstance.promotedProductListener.collect { product ->\n            product?.let {\n                // Show promoted product immediately\n                showProductDetail(it)\n                \n                // Optionally auto-purchase\n                if (userSettings.autoPromotedPurchase) {\n                    kmpIapInstance.buyPromotedProductIOS()\n                }\n            }\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"android-billing-client-state",children:"Android Billing Client State"}),"\n",(0,s.jsx)(n.p,{children:"While not exposed as a direct flow, Android billing client state changes can be monitored:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'// Monitor through connection state\nscope.launch {\n    kmpIapInstance.isConnected.collectLatest { connected ->\n        if (connected) {\n            // BillingClient is ready\n            println("Google Play Billing connected")\n        } else {\n            // BillingClient disconnected\n            println("Google Play Billing disconnected")\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"advanced-listener-patterns",children:"Advanced Listener Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"combined-listeners",children:"Combined Listeners"}),"\n",(0,s.jsx)(n.p,{children:"Monitor multiple events simultaneously:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class PurchaseFlowManager(private val iap: InAppPurchase) {\n    \n    private val kmpIAP = KmpIAP()\n    \n    init {\n        // Combine purchase and error flows\n        scope.launch {\n            merge(\n                kmpIAP.purchaseUpdatedListener.map { PurchaseEvent.Success(it) },\n                kmpIAP.purchaseErrorListener.map { PurchaseEvent.Error(it) }\n            ).collectLatest { event ->\n                when (event) {\n                    is PurchaseEvent.Success -> handleSuccess(event.purchase)\n                    is PurchaseEvent.Error -> handleError(event.error)\n                }\n            }\n        }\n    }\n    \n    sealed class PurchaseEvent {\n        data class Success(val purchase: Purchase) : PurchaseEvent()\n        data class Error(val error: PurchaseError) : PurchaseEvent()\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"filtered-listeners",children:"Filtered Listeners"}),"\n",(0,s.jsx)(n.p,{children:"Listen for specific events:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"// Only listen for subscription purchases\nkmpIapInstance.purchaseUpdatedListener\n    .filter { purchase ->\n        purchase.products.any { it.type == PurchaseType.SUBS }\n    }\n    .collectLatest { subscriptionPurchase ->\n        handleSubscriptionPurchase(subscriptionPurchase)\n    }\n\n// Only listen for specific error types\nkmpIAP.purchaseErrorListener\n    .filter { error ->\n        error.code in listOf(\n            ErrorCode.NETWORK_ERROR,\n            ErrorCode.SERVICE_UNAVAILABLE\n        )\n    }\n    .collectLatest { networkError ->\n        scheduleRetry()\n    }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"debounced-listeners",children:"Debounced Listeners"}),"\n",(0,s.jsx)(n.p,{children:"Prevent rapid successive events:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"// Debounce purchase updates\nkmpIapInstance.purchaseUpdatedListener\n    .debounce(500) // Wait 500ms for stable state\n    .collectLatest { purchase ->\n        updatePurchaseUI(purchase)\n    }\n\n// Throttle error messages\nkmpIAP.purchaseErrorListener\n    .throttleLatest(2000) // Max one error dialog per 2 seconds\n    .collectLatest { error ->\n        showErrorDialog(error)\n    }\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"lifecycle-aware-listeners",children:"Lifecycle-Aware Listeners"}),"\n",(0,s.jsx)(n.h3,{id:"compose-integration",children:"Compose Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"@Composable\nfun PurchaseScreen(iap: InAppPurchase) {\n    val lifecycleOwner = LocalLifecycleOwner.current\n    \n    // Purchase updates\n    LaunchedEffect(lifecycleOwner) {\n        lifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n            kmpIapInstance.purchaseUpdatedListener.collectLatest { purchase ->\n                // Only collect when screen is visible\n                showPurchaseSuccess(purchase)\n            }\n        }\n    }\n    \n    // Error handling\n    LaunchedEffect(lifecycleOwner) {\n        lifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n            kmpIAP.purchaseErrorListener.collectLatest { error ->\n                showErrorSnackbar(error.message)\n            }\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"activityfragment-integration",children:"Activity/Fragment Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class PurchaseActivity : AppCompatActivity() {\n    private lateinit var iap: InAppPurchase\n    private val purchaseJobs = mutableListOf<Job>()\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        iap = createInAppPurchase()\n        setupListeners()\n    }\n    \n    private fun setupListeners() {\n        // Lifecycle-aware collection\n        purchaseJobs += lifecycleScope.launch {\n            repeatOnLifecycle(Lifecycle.State.STARTED) {\n                kmpIapInstance.purchaseUpdatedListener.collectLatest { purchase ->\n                    handlePurchaseUpdate(purchase)\n                }\n            }\n        }\n        \n        purchaseJobs += lifecycleScope.launch {\n            repeatOnLifecycle(Lifecycle.State.STARTED) {\n                kmpIapInstance.purchaseErrorListener.collectLatest { error ->\n                    handlePurchaseError(error)\n                }\n            }\n        }\n    }\n    \n    override fun onDestroy() {\n        // Clean up listeners\n        purchaseJobs.forEach { it.cancel() }\n        purchaseJobs.clear()\n        super.onDestroy()\n    }\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"error-recovery-strategies",children:"Error Recovery Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"automatic-retry-with-listeners",children:"Automatic Retry with Listeners"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class ResilientPurchaseManager(private val iap: InAppPurchase) {\n    private val retryDelays = listOf(1000L, 2000L, 4000L, 8000L)\n    private val retryAttempts = mutableMapOf<String, Int>()\n    \n    init {\n        scope.launch {\n            kmpIapInstance.purchaseErrorListener.collectLatest { error ->\n                when (error.code) {\n                    ErrorCode.NETWORK_ERROR,\n                    ErrorCode.SERVICE_UNAVAILABLE -> {\n                        scheduleRetry(error)\n                    }\n                    else -> {\n                        // Non-retryable error\n                        resetRetryCount(error.message)\n                    }\n                }\n            }\n        }\n        \n        scope.launch {\n            kmpIAP.purchaseUpdatedListener.collectLatest { purchase ->\n                // Success - reset retry count\n                resetRetryCount(purchase.productId)\n            }\n        }\n    }\n    \n    private suspend fun scheduleRetry(error: PurchaseError) {\n        val attempt = retryAttempts.getOrDefault(error.message, 0)\n        if (attempt < retryDelays.size) {\n            delay(retryDelays[attempt])\n            retryAttempts[error.message] = attempt + 1\n            // Retry the operation\n            retryLastOperation()\n        }\n    }\n    \n    private fun resetRetryCount(key: String) {\n        retryAttempts.remove(key)\n    }\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"testing-listeners",children:"Testing Listeners"}),"\n",(0,s.jsx)(n.h3,{id:"mock-flow-testing",children:"Mock Flow Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'class MockKmpIAP : KmpIAP {\n    private val _purchaseUpdated = MutableFlow<Purchase>()\n    override val purchaseUpdatedListener: Flow<Purchase> = _purchaseUpdated\n    \n    private val _purchaseError = MutableFlow<PurchaseError>()\n    override val purchaseErrorListener: Flow<PurchaseError> = _purchaseError\n    \n    // Test helpers\n    suspend fun emitPurchase(purchase: Purchase) {\n        _purchaseUpdated.emit(purchase)\n    }\n    \n    suspend fun emitError(error: PurchaseError) {\n        _purchaseError.emit(error)\n    }\n}\n\n// In tests\n@Test\nfun testPurchaseListener() = runTest {\n    val mockIap = MockKmpIAP()\n    var receivedPurchase: Purchase? = null\n    \n    val job = launch {\n        mockIap.purchaseUpdatedListener.collect { purchase ->\n            receivedPurchase = purchase\n        }\n    }\n    \n    // Emit test purchase\n    val testPurchase = Purchase(\n        productId = "test_product",\n        transactionId = "12345"\n    )\n    mockIap.emitPurchase(testPurchase)\n    \n    // Verify\n    advanceUntilIdle()\n    assertEquals("test_product", receivedPurchase?.productId)\n    \n    job.cancel()\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Always collect in coroutine scope"}),": Prevent memory leaks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use lifecycle-aware collection"}),": Stop listening when UI is not visible"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handle all error types"}),": Provide appropriate user feedback"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Debounce/throttle when needed"}),": Prevent UI flooding"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clean up listeners"}),": Cancel jobs when no longer needed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Test listener behavior"}),": Mock flows for unit testing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Combine related flows"}),": Simplify complex event handling"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/kmp-iap/docs/api/core-methods",children:"Core Methods"})," - Methods that trigger events"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/kmp-iap/docs/api/error-codes",children:"Error Codes"})," - Complete error code reference"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/kmp-iap/docs/examples/complete-implementation",children:"Examples"})," - Full listener implementation"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);