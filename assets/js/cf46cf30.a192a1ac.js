"use strict";(self.webpackChunkkmp_iap_docs=self.webpackChunkkmp_iap_docs||[]).push([[3420],{5899:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var t=i(4848),r=i(8453);const o={sidebar_position:2,title:"Subscription Store"},s="Subscription Store Example",a={id:"examples/subscription-store",title:"Subscription Store",description:"A complete subscription store implementation with monthly and yearly plans using kmp-iap.",source:"@site/docs/examples/subscription-store.md",sourceDirName:"examples",slug:"/examples/subscription-store",permalink:"/kmp-iap/docs/examples/subscription-store",draft:!1,unlisted:!1,editUrl:"https://github.com/hyochan/kmp-iap/tree/main/docs/docs/examples/subscription-store.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Subscription Store"},sidebar:"docsSidebar",previous:{title:"Basic Store",permalink:"/kmp-iap/docs/examples/basic-store"},next:{title:"Complete Implementation",permalink:"/kmp-iap/docs/examples/complete-implementation"}},c={},l=[{value:"Features",id:"features",level:2},{value:"Complete Implementation",id:"complete-implementation",level:2},{value:"Key Features Explained",id:"key-features-explained",level:2},{value:"1. Subscription Grouping",id:"1-subscription-grouping",level:3},{value:"2. Status Display",id:"2-status-display",level:3},{value:"3. Visual Hierarchy",id:"3-visual-hierarchy",level:3},{value:"4. Android Subscription Offers",id:"4-android-subscription-offers",level:3},{value:"Best Practices Implemented",id:"best-practices-implemented",level:2},{value:"Enhanced Subscription Management Features",id:"enhanced-subscription-management-features",level:2},{value:"Using New ActiveSubscription APIs",id:"using-new-activesubscription-apis",level:3},{value:"Platform-Specific Subscription Details",id:"platform-specific-subscription-details",level:3},{value:"iOS Features",id:"ios-features",level:4},{value:"Android Features",id:"android-features",level:4},{value:"Visual Subscription Status",id:"visual-subscription-status",level:3},{value:"Legacy Subscription Status Check",id:"legacy-subscription-status-check",level:3},{value:"Handling Grace Periods",id:"handling-grace-periods",level:3},{value:"Testing Considerations",id:"testing-considerations",level:2},{value:"Platform-Specific Features",id:"platform-specific-features",level:2},{value:"iOS Promotional Offers",id:"ios-promotional-offers",level:3},{value:"Android Subscription Management",id:"android-subscription-management",level:3}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h1,{id:"subscription-store-example",children:"Subscription Store Example"}),"\n",(0,t.jsx)(e.p,{children:"A complete subscription store implementation with monthly and yearly plans using kmp-iap."}),"\n",(0,t.jsx)(e.h2,{id:"features",children:"Features"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Multiple subscription tiers"}),"\n",(0,t.jsx)(e.li,{children:"Subscription status display"}),"\n",(0,t.jsx)(e.li,{children:"Automatic renewal handling"}),"\n",(0,t.jsx)(e.li,{children:"Restore purchases"}),"\n",(0,t.jsx)(e.li,{children:"Grace period support"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"complete-implementation",children:"Complete Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'import androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport io.github.hyochan.kmpiap.KmpIAP\nimport io.github.hyochan.kmpiap.data.*\nimport io.github.hyochan.kmpiap.openiap.IapPlatform\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.launch\nimport kotlinx.datetime.*\n\nclass SubscriptionStoreViewModel : ViewModel() {\n    \n    // State management\n    data class SubscriptionState(\n        val isConnected: Boolean = false,\n        val isLoading: Boolean = false,\n        val subscriptions: List<Product> = emptyList(),\n        val activeSubscriptions: List<ActiveSubscription> = emptyList(),\n        val hasActiveSubscription: Boolean = false,\n        val error: String? = null\n    )\n    \n    private val _state = MutableStateFlow(SubscriptionState())\n    val state: StateFlow<SubscriptionState> = _state.asStateFlow()\n    \n    // Your subscription IDs\n    private val subscriptionIds = listOf(\n        "premium_monthly",\n        "premium_yearly",\n        "pro_monthly",\n        "pro_yearly"\n    )\n    \n    init {\n        initializeStore()\n        observeStates()\n    }\n    \n    private fun initializeStore() {\n        viewModelScope.launch {\n            _state.update { it.copy(isLoading = true, error = null) }\n\n            try {\n                kmpIapInstance.initConnection()\n                loadSubscriptions()\n            } catch (e: PurchaseError) {\n                showError("Failed to initialize store: ${e.message}")\n            }\n        }\n    }\n    \n    private fun observeStates() {\n        // Observe connection\n        viewModelScope.launch {\n            KmpIAP.isConnected.collectLatest { connected ->\n                _state.update { it.copy(isConnected = connected) }\n            }\n        }\n        \n        // Observe subscriptions\n        viewModelScope.launch {\n            KmpIAP.subscriptions.collectLatest { subs ->\n                _state.update { it.copy(subscriptions = subs) }\n            }\n        }\n        \n        // Observe active subscriptions using new API\n        viewModelScope.launch {\n            // Check for active subscriptions periodically or when state changes\n            loadActiveSubscriptions()\n        }\n        \n        // Observe purchase updates\n        viewModelScope.launch {\n            KmpIAP.currentPurchase.collectLatest { purchase ->\n                purchase?.let { handlePurchaseUpdate(it) }\n            }\n        }\n        \n        // Observe errors\n        viewModelScope.launch {\n            KmpIAP.currentError.collectLatest { error ->\n                error?.let {\n                    handlePurchaseError(it)\n                    KmpIAP.clearError()\n                }\n            }\n        }\n    }\n    \n    private suspend fun loadSubscriptions() {\n        _state.update { it.copy(isLoading = true, error = null) }\n\n        try {\n            val subscriptions = kmpIapInstance.fetchProducts {\n                skus = subscriptionIds\n                type = ProductQueryType.Subs\n            }\n            println("Loaded ${subscriptions.size} subscriptions")\n\n            // Also load active subscriptions\n            loadActiveSubscriptions()\n        } catch (e: PurchaseError) {\n            showError("Failed to load subscriptions: ${e.message}")\n        } finally {\n            _state.update { it.copy(isLoading = false) }\n        }\n    }\n    \n    private suspend fun loadActiveSubscriptions() {\n        try {\n            // Use new APIs to get active subscription information\n            val activeSubscriptions = kmpIapInstance.getActiveSubscriptions(subscriptionIds)\n            val hasActiveSubscription = kmpIapInstance.hasActiveSubscriptions(subscriptionIds)\n            \n            _state.update { \n                it.copy(\n                    activeSubscriptions = activeSubscriptions,\n                    hasActiveSubscription = hasActiveSubscription\n                ) \n            }\n            \n            println("Found ${activeSubscriptions.size} active subscriptions")\n            activeSubscriptions.forEach { subscription ->\n                println("Active subscription: ${subscription.productId}")\n                \n                // iOS-specific information\n                subscription.expirationDateIOS?.let { expDate ->\n                    val expirationDate = Instant.fromEpochMilliseconds(expDate)\n                    println("  Expires: $expirationDate")\n                }\n                subscription.environmentIOS?.let { env ->\n                    println("  Environment: $env")\n                }\n                subscription.daysUntilExpirationIOS?.let { days ->\n                    println("  Days until expiration: $days")\n                }\n                \n                // Android-specific information\n                subscription.autoRenewingAndroid?.let { autoRenew ->\n                    println("  Auto-renewing: $autoRenew")\n                }\n                \n                // Cross-platform warnings\n                if (subscription.willExpireSoon == true) {\n                    println("  \u26a0\ufe0f This subscription will expire soon!")\n                }\n            }\n        } catch (e: Exception) {\n            showError("Failed to load active subscriptions: ${e.message}")\n        }\n    }\n    \n    private suspend fun handlePurchaseUpdate(purchase: Purchase) {\n        println("Purchase update: ${purchase.productId}")\n        \n        try {\n            // Verify purchase on your server\n            val isValid = verifyPurchase(purchase)\n            \n            if (isValid) {\n                // Deliver subscription access\n                deliverSubscription(purchase)\n                \n                // Complete transaction\n                completeTransaction(purchase)\n                \n                // Reload active subscriptions to reflect changes\n                loadActiveSubscriptions()\n                \n                // Clear current purchase\n                KmpIAP.clearPurchase()\n                \n                showMessage("Subscription activated!")\n            } else {\n                showError("Purchase verification failed")\n            }\n        } catch (e: Exception) {\n            showError("Failed to process purchase: ${e.message}")\n        }\n    }\n    \n    private fun handlePurchaseError(error: PurchaseError) {\n        when (error.code) {\n            ErrorCode.UserCancelled -> {\n                // Silent - user cancelled\n            }\n            ErrorCode.AlreadyOwned -> {\n                showMessage("You already have an active subscription")\n            }\n            else -> {\n                showError("Purchase failed: ${error.message}")\n            }\n        }\n    }\n    \n    fun requestSubscription(productId: String) {\n        viewModelScope.launch {\n            try {\n                // For Android, you might want to handle subscription offers\n                if (kmpIapInstance.getPlatform() == IapPlatform.Android) {\n                    // Get available offers for the subscription\n                    val product = _state.value.subscriptions.find { it.productId == productId }\n                    val offers = product?.subscriptionOffers\n\n                    if (!offers.isNullOrEmpty()) {\n                        // Use the first offer (you might want to let user choose)\n                        kmpIapInstance.requestPurchase {\n                            ios { sku = productId }\n                            android {\n                                skus = listOf(productId)\n                                subscriptionOffers = listOf(\n                                    SubscriptionOfferAndroid(\n                                        sku = productId,\n                                        offerToken = offers.first().offerToken\n                                    )\n                                )\n                            }\n                        }\n                    } else {\n                        kmpIapInstance.requestPurchase {\n                            ios { sku = productId }\n                            android { skus = listOf(productId) }\n                        }\n                    }\n                } else {\n                    // iOS doesn\'t need offer tokens\n                    kmpIapInstance.requestPurchase {\n                        ios { sku = productId }\n                        android { skus = listOf(productId) }\n                    }\n                }\n            } catch (e: PurchaseError) {\n                showError("Failed to request subscription: ${e.message}")\n            }\n        }\n    }\n    \n    fun restorePurchases() {\n        viewModelScope.launch {\n            _state.update { it.copy(isLoading = true, error = null) }\n            \n            try {\n                // Get available purchases - this automatically refreshes\n                val purchases = KmpIAP.availablePurchases.value\n                val activeCount = purchases.count { \n                    subscriptionIds.contains(it.productId) && isSubscriptionActive(it)\n                }\n                \n                showMessage("Restored $activeCount active subscriptions")\n            } catch (e: PurchaseError) {\n                showError("Failed to restore purchases: ${e.message}")\n            } finally {\n                _state.update { it.copy(isLoading = false) }\n            }\n        }\n    }\n    \n    private suspend fun verifyPurchase(purchase: Purchase): Boolean {\n        // TODO: Implement server-side verification\n        // This should verify the receipt with your backend\n        return true\n    }\n    \n    private fun deliverSubscription(purchase: Purchase) {\n        // TODO: Grant subscription access to user\n        println("Delivering subscription: ${purchase.productId}")\n    }\n    \n    private suspend fun completeTransaction(purchase: Purchase) {\n        val success = kmpIapInstance.finishTransaction(\n            purchase.toPurchaseInput(),\n            isConsumable = false // Subscriptions are non-consumable\n        )\n\n        if (success) {\n            println("Transaction completed successfully")\n        }\n    }\n    \n    private fun isSubscriptionActive(purchase: Purchase): Boolean {\n        // For a real implementation, check expiration date\n        // This is a simplified version\n        return when (purchase.purchaseState) {\n            PurchaseState.PURCHASED -> true\n            PurchaseState.PENDING -> true // Show as active during pending\n            else -> false\n        }\n    }\n    \n    fun getSubscriptionTier(productId: String): String {\n        return when {\n            productId.contains("premium") -> "Premium"\n            productId.contains("pro") -> "Pro"\n            else -> "Basic"\n        }\n    }\n    \n    fun getSubscriptionPeriod(productId: String): String {\n        return when {\n            productId.contains("monthly") -> "Monthly"\n            productId.contains("yearly") -> "Yearly"\n            else -> ""\n        }\n    }\n    \n    fun getTierColor(tier: String): Color {\n        return when (tier.lowercase()) {\n            "premium" -> Color(0xFFFFA726) // Orange\n            "pro" -> Color(0xFF9C27B0) // Purple\n            else -> Color(0xFF2196F3) // Blue\n        }\n    }\n    \n    private fun showError(message: String) {\n        _state.update { it.copy(error = message) }\n    }\n    \n    private fun showMessage(message: String) {\n        // In a real app, show a snackbar\n        println("\u2139\ufe0f $message")\n    }\n    \n    fun clearError() {\n        _state.update { it.copy(error = null) }\n    }\n    \n    override fun onCleared() {\n        super.onCleared()\n        kmpIapInstance.endConnection()\n    }\n}\n\n@Composable\nfun SubscriptionStoreScreen(\n    viewModel: SubscriptionStoreViewModel = viewModel()\n) {\n    val state by viewModel.state.collectAsState()\n    \n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = { Text("Premium Subscriptions") },\n                actions = {\n                    IconButton(\n                        onClick = viewModel::restorePurchases,\n                        enabled = !state.isLoading\n                    ) {\n                        Icon(\n                            Icons.Default.Restore,\n                            contentDescription = "Restore Purchases"\n                        )\n                    }\n                }\n            )\n        }\n    ) { paddingValues ->\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(paddingValues)\n        ) {\n            when {\n                state.isLoading && state.subscriptions.isEmpty() -> {\n                    CircularProgressIndicator(\n                        modifier = Modifier.align(Alignment.Center)\n                    )\n                }\n                else -> {\n                    SubscriptionPlans(\n                        state = state,\n                        viewModel = viewModel\n                    )\n                }\n            }\n            \n            // Error banner\n            state.error?.let { error ->\n                Surface(\n                    modifier = Modifier.fillMaxWidth(),\n                    color = MaterialTheme.colorScheme.errorContainer\n                ) {\n                    Row(\n                        modifier = Modifier.padding(16.dp),\n                        verticalAlignment = Alignment.CenterVertically\n                    ) {\n                        Icon(\n                            Icons.Default.Error,\n                            contentDescription = null,\n                            tint = MaterialTheme.colorScheme.onErrorContainer\n                        )\n                        Spacer(modifier = Modifier.width(8.dp))\n                        Text(\n                            text = error,\n                            modifier = Modifier.weight(1f),\n                            color = MaterialTheme.colorScheme.onErrorContainer\n                        )\n                        IconButton(onClick = viewModel::clearError) {\n                            Icon(\n                                Icons.Default.Close,\n                                contentDescription = "Dismiss",\n                                tint = MaterialTheme.colorScheme.onErrorContainer\n                            )\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun SubscriptionPlans(\n    state: SubscriptionStoreViewModel.SubscriptionState,\n    viewModel: SubscriptionStoreViewModel\n) {\n    // Group subscriptions by tier\n    val groupedSubs = state.subscriptions.groupBy { \n        viewModel.getSubscriptionTier(it.productId) \n    }\n    \n    LazyColumn(\n        contentPadding = PaddingValues(16.dp),\n        verticalArrangement = Arrangement.spacedBy(16.dp)\n    ) {\n        // Current Status\n        item {\n            CurrentSubscriptionStatus(\n                activeSubscriptions = state.activeSubscriptions,\n                hasActiveSubscription = state.hasActiveSubscription,\n                viewModel = viewModel\n            )\n        }\n        \n        // Subscription Plans Header\n        item {\n            Text(\n                "Choose Your Plan",\n                style = MaterialTheme.typography.headlineSmall,\n                modifier = Modifier.padding(vertical = 8.dp)\n            )\n        }\n        \n        // Subscription Tiers\n        groupedSubs.forEach { (tier, subscriptions) ->\n            item {\n                SubscriptionTierSection(\n                    tier = tier,\n                    subscriptions = subscriptions,\n                    activeSubscriptions = state.activeSubscriptions,\n                    hasActiveSubscription = state.hasActiveSubscription,\n                    viewModel = viewModel\n                )\n            }\n        }\n    }\n}\n\n@Composable\nfun CurrentSubscriptionStatus(\n    activeSubscriptions: List<ActiveSubscription>,\n    hasActiveSubscription: Boolean,\n    viewModel: SubscriptionStoreViewModel\n) {\n    Card(\n        modifier = Modifier.fillMaxWidth(),\n        colors = CardDefaults.cardColors(\n            containerColor = if (!hasActiveSubscription)\n                MaterialTheme.colorScheme.surfaceVariant\n            else\n                Color(0xFF4CAF50).copy(alpha = 0.1f)\n        )\n    ) {\n        Row(\n            modifier = Modifier.padding(16.dp),\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            Icon(\n                imageVector = if (!hasActiveSubscription)\n                    Icons.Default.Info\n                else\n                    Icons.Default.CheckCircle,\n                contentDescription = null,\n                tint = if (!hasActiveSubscription)\n                    MaterialTheme.colorScheme.onSurfaceVariant\n                else\n                    Color(0xFF4CAF50)\n            )\n            Spacer(modifier = Modifier.width(12.dp))\n            Column {\n                Text(\n                    text = if (!hasActiveSubscription)\n                        "No active subscriptions"\n                    else\n                        "Active Subscriptions",\n                    style = MaterialTheme.typography.titleMedium,\n                    fontWeight = FontWeight.Bold\n                )\n                \n                activeSubscriptions.forEach { sub ->\n                    Column {\n                        Text(\n                            text = "${viewModel.getSubscriptionTier(sub.productId)} ${viewModel.getSubscriptionPeriod(sub.productId)}",\n                            style = MaterialTheme.typography.bodyMedium,\n                            color = Color(0xFF4CAF50)\n                        )\n                        \n                        // Show expiration information\n                        sub.expirationDateIOS?.let { expDate ->\n                            val expirationDate = Instant.fromEpochMilliseconds(expDate)\n                            Text(\n                                text = "Expires: ${expirationDate.toLocalDateTime(TimeZone.currentSystemDefault()).date}",\n                                style = MaterialTheme.typography.bodySmall,\n                                color = MaterialTheme.colorScheme.onSurfaceVariant\n                            )\n                        }\n                        \n                        // Show environment (iOS)\n                        sub.environmentIOS?.let { env ->\n                            if (env == "Sandbox") {\n                                Text(\n                                    text = "\ud83e\uddea Sandbox",\n                                    style = MaterialTheme.typography.bodySmall,\n                                    color = Color(0xFFFF9800)\n                                )\n                            }\n                        }\n                        \n                        // Show expiration warning\n                        if (sub.willExpireSoon == true) {\n                            Text(\n                                text = "\u26a0\ufe0f Expires soon",\n                                style = MaterialTheme.typography.bodySmall,\n                                color = Color(0xFFFF5722)\n                            )\n                        }\n                        \n                        // Show auto-renewal status (Android)\n                        sub.autoRenewingAndroid?.let { autoRenew ->\n                            Text(\n                                text = if (autoRenew) "\ud83d\udd04 Auto-renewing" else "\u23f8\ufe0f Will not renew",\n                                style = MaterialTheme.typography.bodySmall,\n                                color = if (autoRenew) Color(0xFF4CAF50) else Color(0xFFFF5722)\n                            )\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun SubscriptionTierSection(\n    tier: String,\n    subscriptions: List<Product>,\n    activeSubscriptions: List<ActiveSubscription>,\n    hasActiveSubscription: Boolean,\n    viewModel: SubscriptionStoreViewModel\n) {\n    val tierColor = viewModel.getTierColor(tier)\n    \n    Card(\n        modifier = Modifier.fillMaxWidth(),\n        colors = CardDefaults.cardColors()\n    ) {\n        Column {\n            // Tier Header\n            Surface(\n                modifier = Modifier.fillMaxWidth(),\n                color = tierColor.copy(alpha = 0.1f)\n            ) {\n                Text(\n                    text = tier,\n                    modifier = Modifier.padding(16.dp),\n                    style = MaterialTheme.typography.titleLarge,\n                    fontWeight = FontWeight.Bold,\n                    color = tierColor\n                )\n            }\n            \n            // Subscription Options\n            subscriptions.forEach { subscription ->\n                SubscriptionTile(\n                    subscription = subscription,\n                    isActive = activeSubscriptions.any { \n                        it.productId == subscription.productId \n                    },\n                    tierColor = tierColor,\n                    onSubscribe = { viewModel.requestSubscription(subscription.productId) }\n                )\n                \n                if (subscription != subscriptions.last()) {\n                    Divider()\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun SubscriptionTile(\n    subscription: Product,\n    isActive: Boolean,\n    tierColor: Color,\n    onSubscribe: () -> Unit\n) {\n    ListItem(\n        headlineContent = {\n            Text(subscription.title)\n        },\n        supportingContent = {\n            subscription.description?.let { Text(it) }\n        },\n        trailingContent = {\n            if (isActive) {\n                Surface(\n                    shape = MaterialTheme.shapes.small,\n                    color = Color(0xFF4CAF50),\n                    contentColor = Color.White\n                ) {\n                    Text(\n                        text = "ACTIVE",\n                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp),\n                        style = MaterialTheme.typography.labelSmall,\n                        fontWeight = FontWeight.Bold\n                    )\n                }\n            } else {\n                Button(\n                    onClick = onSubscribe,\n                    colors = ButtonDefaults.buttonColors(\n                        containerColor = tierColor\n                    )\n                ) {\n                    Text(subscription.price)\n                }\n            }\n        }\n    )\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"key-features-explained",children:"Key Features Explained"}),"\n",(0,t.jsx)(e.h3,{id:"1-subscription-grouping",children:"1. Subscription Grouping"}),"\n",(0,t.jsx)(e.p,{children:"The store groups subscriptions by tier (Premium, Pro) for better organization:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"val groupedSubs = state.subscriptions.groupBy { \n    viewModel.getSubscriptionTier(it.productId) \n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-status-display",children:"2. Status Display"}),"\n",(0,t.jsx)(e.p,{children:"Shows current subscription status prominently:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"@Composable\nfun CurrentSubscriptionStatus(\n    activeSubscriptions: List<Purchase>,\n    viewModel: SubscriptionStoreViewModel\n) {\n    // Visual indication of active subscriptions\n    // Different colors and icons for active vs inactive\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-visual-hierarchy",children:"3. Visual Hierarchy"}),"\n",(0,t.jsx)(e.p,{children:"Different colors and styling for different subscription tiers:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'fun getTierColor(tier: String): Color {\n    return when (tier.lowercase()) {\n        "premium" -> Color(0xFFFFA726) // Orange\n        "pro" -> Color(0xFF9C27B0) // Purple\n        else -> Color(0xFF2196F3) // Blue\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"4-android-subscription-offers",children:"4. Android Subscription Offers"}),"\n",(0,t.jsx)(e.p,{children:"Handles Android subscription offers properly:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"if (kmpIapInstance.getPlatform() == IapPlatform.Android) {\n    val offers = product?.subscriptionOffers\n    if (!offers.isNullOrEmpty()) {\n        kmpIapInstance.requestPurchase {\n            ios { sku = productId }\n            android {\n                skus = listOf(productId)\n                subscriptionOffers = listOf(\n                    SubscriptionOfferAndroid(\n                        sku = productId,\n                        offerToken = offers.first().offerToken\n                    )\n                )\n            }\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"best-practices-implemented",children:"Best Practices Implemented"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Error Handling"}),": Comprehensive error handling with user-friendly messages"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Loading States"}),": Shows loading indicators during async operations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Purchase Verification"}),": Placeholder for server-side verification"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Transaction Completion"}),": Proper handling of iOS and Android differences"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Restore Functionality"}),": Easy way for users to restore purchases"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Status Display"}),": Clear indication of active subscriptions with detailed information"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"StateFlow Usage"}),": Reactive state management with Kotlin StateFlow"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Enhanced Subscription Management"}),": Uses new ",(0,t.jsx)(e.code,{children:"getActiveSubscriptions()"})," and ",(0,t.jsx)(e.code,{children:"hasActiveSubscriptions()"})," APIs"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Platform-Specific Details"}),": Shows expiration dates (iOS), auto-renewal status (Android), and environment info"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"enhanced-subscription-management-features",children:"Enhanced Subscription Management Features"}),"\n",(0,t.jsx)(e.h3,{id:"using-new-activesubscription-apis",children:"Using New ActiveSubscription APIs"}),"\n",(0,t.jsx)(e.p,{children:"The example now uses the enhanced subscription APIs for more detailed information:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'// Check if user has any active subscriptions (quick check)\nval hasActiveSubscription = kmpIapInstance.hasActiveSubscriptions(subscriptionIds)\n\n// Get detailed subscription information\nval activeSubscriptions = kmpIapInstance.getActiveSubscriptions(subscriptionIds)\n\nactiveSubscriptions.forEach { subscription ->\n    println("Active subscription: ${subscription.productId}")\n    \n    // iOS-specific information\n    subscription.expirationDateIOS?.let { expDate ->\n        val expirationDate = Instant.fromEpochMilliseconds(expDate)\n        println("  Expires: $expirationDate")\n    }\n    subscription.environmentIOS?.let { env ->\n        println("  Environment: $env") // "Sandbox" or "Production"\n    }\n    subscription.daysUntilExpirationIOS?.let { days ->\n        println("  Days until expiration: $days")\n    }\n    \n    // Android-specific information\n    subscription.autoRenewingAndroid?.let { autoRenew ->\n        println("  Auto-renewing: $autoRenew")\n    }\n    \n    // Cross-platform warnings\n    if (subscription.willExpireSoon == true) {\n        println("  \u26a0\ufe0f This subscription will expire soon!")\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"platform-specific-subscription-details",children:"Platform-Specific Subscription Details"}),"\n",(0,t.jsx)(e.h4,{id:"ios-features",children:"iOS Features"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Expiration Date"}),": Exact timestamp when subscription expires"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Environment Detection"}),": Automatically detects Sandbox vs Production"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Days Until Expiration"}),": Calculated remaining days"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Expiration Warnings"}),": ",(0,t.jsx)(e.code,{children:"willExpireSoon"})," flag for subscriptions expiring within 7 days"]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"android-features",children:"Android Features"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Auto-Renewal Status"}),": Shows if subscription will automatically renew"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Grace Period Support"}),": Can be extended with server-side validation"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"visual-subscription-status",children:"Visual Subscription Status"}),"\n",(0,t.jsx)(e.p,{children:"The UI now shows rich subscription information:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'// Show expiration information\nsub.expirationDateIOS?.let { expDate ->\n    val expirationDate = Instant.fromEpochMilliseconds(expDate)\n    Text(\n        text = "Expires: ${expirationDate.toLocalDateTime(TimeZone.currentSystemDefault()).date}",\n        style = MaterialTheme.typography.bodySmall,\n        color = MaterialTheme.colorScheme.onSurfaceVariant\n    )\n}\n\n// Show environment (iOS)\nsub.environmentIOS?.let { env ->\n    if (env == "Sandbox") {\n        Text(\n            text = "\ud83e\uddea Sandbox",\n            style = MaterialTheme.typography.bodySmall,\n            color = Color(0xFFFF9800)\n        )\n    }\n}\n\n// Show expiration warning\nif (sub.willExpireSoon == true) {\n    Text(\n        text = "\u26a0\ufe0f Expires soon",\n        style = MaterialTheme.typography.bodySmall,\n        color = Color(0xFFFF5722)\n    )\n}\n\n// Show auto-renewal status (Android)\nsub.autoRenewingAndroid?.let { autoRenew ->\n    Text(\n        text = if (autoRenew) "\ud83d\udd04 Auto-renewing" else "\u23f8\ufe0f Will not renew",\n        style = MaterialTheme.typography.bodySmall,\n        color = if (autoRenew) Color(0xFF4CAF50) else Color(0xFFFF5722)\n    )\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"legacy-subscription-status-check",children:"Legacy Subscription Status Check"}),"\n",(0,t.jsx)(e.p,{children:"For backward compatibility, you can still use the basic check:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"private fun isSubscriptionActive(purchase: Purchase): Boolean {\n    // In production, check actual expiration date\n    return when (purchase.purchaseState) {\n        PurchaseState.PURCHASED -> true\n        PurchaseState.PENDING -> true // Show as active during pending\n        else -> false\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"handling-grace-periods",children:"Handling Grace Periods"}),"\n",(0,t.jsx)(e.p,{children:"For production apps, implement grace period handling:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"private fun checkSubscriptionWithGracePeriod(purchase: Purchase): SubscriptionStatus {\n    val expirationDate = purchase.expirationDate ?: return SubscriptionStatus.EXPIRED\n    val now = Clock.System.now()\n    \n    return when {\n        now < expirationDate -> SubscriptionStatus.ACTIVE\n        now < expirationDate.plus(3.days) -> SubscriptionStatus.IN_GRACE_PERIOD\n        else -> SubscriptionStatus.EXPIRED\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"testing-considerations",children:"Testing Considerations"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Test with different subscription tiers"}),"\n",(0,t.jsx)(e.li,{children:"Test restoration on device reinstall"}),"\n",(0,t.jsx)(e.li,{children:"Test subscription expiration handling"}),"\n",(0,t.jsx)(e.li,{children:"Test grace period scenarios"}),"\n",(0,t.jsx)(e.li,{children:"Test with different payment methods"}),"\n",(0,t.jsx)(e.li,{children:"Test subscription upgrades/downgrades"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"platform-specific-features",children:"Platform-Specific Features"}),"\n",(0,t.jsx)(e.h3,{id:"ios-promotional-offers",children:"iOS Promotional Offers"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"// iOS specific - check for promotional offers\nif (kmpIapInstance.getPlatform() == IapPlatform.Ios) {\n    viewModelScope.launch {\n        kmpIapInstance.promotedProductIOS.collectLatest { promotedProduct ->\n            // Handle App Store promoted product\n            promotedProduct?.let {\n                // Show promoted product UI\n            }\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"android-subscription-management",children:"Android Subscription Management"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"// Android specific - deep link to subscription management\nsuspend fun openSubscriptionManagement(productId: String) {\n    if (kmpIapInstance.getPlatform() == IapPlatform.Android) {\n        kmpIapInstance.deepLinkToSubscriptions(productId)\n    }\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"This example provides a solid foundation for a subscription-based app with multiple tiers and billing periods using Kotlin Multiplatform."})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(p,{...n})}):p(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>a});var t=i(6540);const r={},o=t.createContext(r);function s(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);