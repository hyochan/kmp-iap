"use strict";(self.webpackChunkkmp_iap_docs=self.webpackChunkkmp_iap_docs||[]).push([[2746],{2201:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var s=r(4848),t=r(8453),c=r(5159);const i={title:"Listeners",sidebar_position:4},a="Listeners",o={id:"api/listeners",title:"Listeners",description:"Event listeners and flow collectors for monitoring purchase updates, errors, and connection states in kmp-iap.",source:"@site/versioned_docs/version-1.0.0-rc/api/listeners.md",sourceDirName:"api",slug:"/api/listeners",permalink:"/kmp-iap/docs/1.0.0-rc/api/listeners",draft:!1,unlisted:!1,editUrl:"https://github.com/hyochan/kmp-iap/tree/main/docs/versioned_docs/version-1.0.0-rc/api/listeners.md",tags:[],version:"1.0.0-rc",sidebarPosition:4,frontMatter:{title:"Listeners",sidebar_position:4},sidebar:"docsSidebar",previous:{title:"Core Methods",permalink:"/kmp-iap/docs/1.0.0-rc/api/core-methods"},next:{title:"Error Codes",permalink:"/kmp-iap/docs/1.0.0-rc/api/error-codes"}},l={},d=[{value:"Purchase Update Listener",id:"purchase-update-listener",level:2},{value:"purchaseUpdatedListener",id:"purchaseupdatedlistener",level:3},{value:"Error Listener",id:"error-listener",level:2},{value:"purchaseErrorListener",id:"purchaseerrorlistener",level:3},{value:"Connection State Listener",id:"connection-state-listener",level:2},{value:"Connection State",id:"connection-state",level:3},{value:"Platform-Specific Listeners",id:"platform-specific-listeners",level:2},{value:"iOS Promoted Product Listener",id:"ios-promoted-product-listener",level:3},{value:"Android Billing Client State",id:"android-billing-client-state",level:3},{value:"Advanced Listener Patterns",id:"advanced-listener-patterns",level:2},{value:"Combined Listeners",id:"combined-listeners",level:3},{value:"Filtered Listeners",id:"filtered-listeners",level:3},{value:"Debounced Listeners",id:"debounced-listeners",level:3},{value:"Lifecycle-Aware Listeners",id:"lifecycle-aware-listeners",level:2},{value:"Compose Integration",id:"compose-integration",level:3},{value:"Activity/Fragment Integration",id:"activityfragment-integration",level:3},{value:"Error Recovery Strategies",id:"error-recovery-strategies",level:2},{value:"Automatic Retry with Listeners",id:"automatic-retry-with-listeners",level:3},{value:"Testing Listeners",id:"testing-listeners",level:2},{value:"Mock Flow Testing",id:"mock-flow-testing",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"See Also",id:"see-also",level:2}];function p(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"listeners",children:"Listeners"}),"\n",(0,s.jsx)(c.A,{}),"\n",(0,s.jsx)(n.p,{children:"Event listeners and flow collectors for monitoring purchase updates, errors, and connection states in kmp-iap."}),"\n",(0,s.jsx)(n.h2,{id:"purchase-update-listener",children:"Purchase Update Listener"}),"\n",(0,s.jsx)(n.h3,{id:"purchaseupdatedlistener",children:"purchaseUpdatedListener"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"val purchaseUpdatedListener: Flow<Purchase>\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type"}),": ",(0,s.jsx)(n.code,{children:"Flow<Purchase>"}),(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Description"}),": Emits purchase updates when transactions occur",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Emission"}),": Triggered on successful purchase completion"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'import kotlinx.coroutines.flow.collectLatest\n\nclass PurchaseManager {\n    private val kmpIAP = KmpIAP()\n    private val scope = CoroutineScope(Dispatchers.Main)\n    \n    init {\n        scope.launch {\n            kmpIAP.purchaseUpdatedListener.collectLatest { purchase ->\n                println("Purchase updated: \\${purchase.productId}")\n                println("Transaction ID: \\${purchase.transactionId}")\n                println("State: \\${purchase.purchaseState}")\n                \n                // Handle purchase based on state\n                when (purchase.purchaseState) {\n                    PurchaseState.PURCHASED -> {\n                        handleSuccessfulPurchase(purchase)\n                    }\n                    PurchaseState.PENDING -> {\n                        handlePendingPurchase(purchase)\n                    }\n                    else -> {\n                        println("Unexpected purchase state")\n                    }\n                }\n            }\n        }\n    }\n    \n    private suspend fun handleSuccessfulPurchase(purchase: Purchase) {\n        // Validate purchase\n        validatePurchase(purchase)\n        \n        // Grant entitlement\n        grantEntitlement(purchase.productId)\n        \n        // Finish transaction\n        kmpIAP.finishTransaction(purchase, isConsumable = true)\n    }\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"error-listener",children:"Error Listener"}),"\n",(0,s.jsx)(n.h3,{id:"purchaseerrorlistener",children:"purchaseErrorListener"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"val purchaseErrorListener: Flow<PurchaseError>\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type"}),": ",(0,s.jsx)(n.code,{children:"Flow<PurchaseError>"}),(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Description"}),": Emits errors that occur during purchase operations",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Emission"}),": Triggered on any purchase-related error"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'import io.github.hyochan.kmpiap.kmpIapInstance\n\nscope.launch {\n    kmpIapInstance.purchaseErrorListener.collectLatest { error ->\n        println("Purchase error: \\${error.message}")\n        println("Error code: \\${error.code}")\n        \n        when (error.code) {\n            ErrorCode.USER_CANCELLED -> {\n                // User cancelled, no action needed\n                println("User cancelled the purchase")\n            }\n            ErrorCode.NETWORK_ERROR -> {\n                showRetryDialog("Network error. Please check your connection.")\n            }\n            ErrorCode.ITEM_UNAVAILABLE -> {\n                showError("This item is not available in your region.")\n            }\n            ErrorCode.ALREADY_OWNED -> {\n                showInfo("You already own this item.")\n                refreshOwnedPurchases()\n            }\n            else -> {\n                showError("Purchase failed: \\${error.message}")\n            }\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"connection-state-listener",children:"Connection State Listener"}),"\n",(0,s.jsx)(n.h3,{id:"connection-state",children:"Connection State"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"suspend fun isConnected(): Boolean\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type"}),": ",(0,s.jsx)(n.code,{children:"suspend fun"}),(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Description"}),": Check connection state to the store service",(0,s.jsx)(n.br,{}),"\n",(0,s.jsx)(n.strong,{children:"Returns"}),": ",(0,s.jsx)(n.code,{children:"Boolean"})," - true if connected"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'// Check connection state\nscope.launch {\n    val connected = kmpIapInstance.isConnected()\n    if (connected) {\n        enablePurchaseButtons()\n        loadProducts()\n    } else {\n        disablePurchaseButtons()\n        showConnectionError()\n    }\n}\n\n// Connection state with retry\nclass ConnectionManager(private val iap: InAppPurchase) {\n    private var retryCount = 0\n    private val maxRetries = 3\n    \n    init {\n        monitorConnection()\n    }\n    \n    private fun monitorConnection() {\n        scope.launch {\n            kmpIapInstance.isConnected.collectLatest { connected ->\n                if (!connected && retryCount < maxRetries) {\n                    delay(2000 * (retryCount + 1)) // Exponential backoff\n                    retryCount++\n                    try {\n                        kmpIapInstance.initConnection()\n                    } catch (e: Exception) {\n                        println("Retry failed: \\${e.message}")\n                    }\n                } else if (connected) {\n                    retryCount = 0\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"platform-specific-listeners",children:"Platform-Specific Listeners"}),"\n",(0,s.jsx)(n.h3,{id:"ios-promoted-product-listener",children:"iOS Promoted Product Listener"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"val promotedProductListener: Flow<String?>\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Type"}),": ",(0,s.jsx)(n.code,{children:"Flow<String?>"}),"\n",(0,s.jsx)(n.strong,{children:"Platform"}),": iOS only\n",(0,s.jsx)(n.strong,{children:"Description"}),": Product ID of promoted product from App Store that triggered app launch"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"if (getCurrentPlatform() == IapPlatform.IOS) {\n    scope.launch {\n        kmpIapInstance.promotedProductListener.collect { productId ->\n            productId?.let {\n                // Fetch product details using the product ID\n                val products = kmpIapInstance.getProducts(\n                    GetProductsProps(skus = listOf(it))\n                )\n                products.firstOrNull()?.let { product ->\n                    showProductDetail(product)\n                }\n\n                // Optionally auto-purchase\n                if (userSettings.autoPromotedPurchase) {\n                    kmpIapInstance.buyPromotedProductIOS()\n                }\n            }\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"android-billing-client-state",children:"Android Billing Client State"}),"\n",(0,s.jsx)(n.p,{children:"While not exposed as a direct flow, Android billing client state changes can be monitored:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'// Monitor through connection state\nscope.launch {\n    kmpIapInstance.isConnected.collectLatest { connected ->\n        if (connected) {\n            // BillingClient is ready\n            println("Google Play Billing connected")\n        } else {\n            // BillingClient disconnected\n            println("Google Play Billing disconnected")\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"advanced-listener-patterns",children:"Advanced Listener Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"combined-listeners",children:"Combined Listeners"}),"\n",(0,s.jsx)(n.p,{children:"Monitor multiple events simultaneously:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class PurchaseFlowManager(private val iap: InAppPurchase) {\n    \n    private val kmpIAP = KmpIAP()\n    \n    init {\n        // Combine purchase and error flows\n        scope.launch {\n            merge(\n                kmpIAP.purchaseUpdatedListener.map { PurchaseEvent.Success(it) },\n                kmpIAP.purchaseErrorListener.map { PurchaseEvent.Error(it) }\n            ).collectLatest { event ->\n                when (event) {\n                    is PurchaseEvent.Success -> handleSuccess(event.purchase)\n                    is PurchaseEvent.Error -> handleError(event.error)\n                }\n            }\n        }\n    }\n    \n    sealed class PurchaseEvent {\n        data class Success(val purchase: Purchase) : PurchaseEvent()\n        data class Error(val error: PurchaseError) : PurchaseEvent()\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"filtered-listeners",children:"Filtered Listeners"}),"\n",(0,s.jsx)(n.p,{children:"Listen for specific events:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"// Only listen for subscription purchases\nkmpIapInstance.purchaseUpdatedListener\n    .filter { purchase ->\n        purchase.products.any { it.type == PurchaseType.SUBS }\n    }\n    .collectLatest { subscriptionPurchase ->\n        handleSubscriptionPurchase(subscriptionPurchase)\n    }\n\n// Only listen for specific error types\nkmpIAP.purchaseErrorListener\n    .filter { error ->\n        error.code in listOf(\n            ErrorCode.NETWORK_ERROR,\n            ErrorCode.SERVICE_UNAVAILABLE\n        )\n    }\n    .collectLatest { networkError ->\n        scheduleRetry()\n    }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"debounced-listeners",children:"Debounced Listeners"}),"\n",(0,s.jsx)(n.p,{children:"Prevent rapid successive events:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"// Debounce purchase updates\nkmpIapInstance.purchaseUpdatedListener\n    .debounce(500) // Wait 500ms for stable state\n    .collectLatest { purchase ->\n        updatePurchaseUI(purchase)\n    }\n\n// Throttle error messages\nkmpIAP.purchaseErrorListener\n    .throttleLatest(2000) // Max one error dialog per 2 seconds\n    .collectLatest { error ->\n        showErrorDialog(error)\n    }\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"lifecycle-aware-listeners",children:"Lifecycle-Aware Listeners"}),"\n",(0,s.jsx)(n.h3,{id:"compose-integration",children:"Compose Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"@Composable\nfun PurchaseScreen(iap: InAppPurchase) {\n    val lifecycleOwner = LocalLifecycleOwner.current\n    \n    // Purchase updates\n    LaunchedEffect(lifecycleOwner) {\n        lifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n            kmpIapInstance.purchaseUpdatedListener.collectLatest { purchase ->\n                // Only collect when screen is visible\n                showPurchaseSuccess(purchase)\n            }\n        }\n    }\n    \n    // Error handling\n    LaunchedEffect(lifecycleOwner) {\n        lifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n            kmpIAP.purchaseErrorListener.collectLatest { error ->\n                showErrorSnackbar(error.message)\n            }\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"activityfragment-integration",children:"Activity/Fragment Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class PurchaseActivity : AppCompatActivity() {\n    private lateinit var iap: InAppPurchase\n    private val purchaseJobs = mutableListOf<Job>()\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        iap = createInAppPurchase()\n        setupListeners()\n    }\n    \n    private fun setupListeners() {\n        // Lifecycle-aware collection\n        purchaseJobs += lifecycleScope.launch {\n            repeatOnLifecycle(Lifecycle.State.STARTED) {\n                kmpIapInstance.purchaseUpdatedListener.collectLatest { purchase ->\n                    handlePurchaseUpdate(purchase)\n                }\n            }\n        }\n        \n        purchaseJobs += lifecycleScope.launch {\n            repeatOnLifecycle(Lifecycle.State.STARTED) {\n                kmpIapInstance.purchaseErrorListener.collectLatest { error ->\n                    handlePurchaseError(error)\n                }\n            }\n        }\n    }\n    \n    override fun onDestroy() {\n        // Clean up listeners\n        purchaseJobs.forEach { it.cancel() }\n        purchaseJobs.clear()\n        super.onDestroy()\n    }\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"error-recovery-strategies",children:"Error Recovery Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"automatic-retry-with-listeners",children:"Automatic Retry with Listeners"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class ResilientPurchaseManager(private val iap: InAppPurchase) {\n    private val retryDelays = listOf(1000L, 2000L, 4000L, 8000L)\n    private val retryAttempts = mutableMapOf<String, Int>()\n    \n    init {\n        scope.launch {\n            kmpIapInstance.purchaseErrorListener.collectLatest { error ->\n                when (error.code) {\n                    ErrorCode.NETWORK_ERROR,\n                    ErrorCode.SERVICE_UNAVAILABLE -> {\n                        scheduleRetry(error)\n                    }\n                    else -> {\n                        // Non-retryable error\n                        resetRetryCount(error.message)\n                    }\n                }\n            }\n        }\n        \n        scope.launch {\n            kmpIAP.purchaseUpdatedListener.collectLatest { purchase ->\n                // Success - reset retry count\n                resetRetryCount(purchase.productId)\n            }\n        }\n    }\n    \n    private suspend fun scheduleRetry(error: PurchaseError) {\n        val attempt = retryAttempts.getOrDefault(error.message, 0)\n        if (attempt < retryDelays.size) {\n            delay(retryDelays[attempt])\n            retryAttempts[error.message] = attempt + 1\n            // Retry the operation\n            retryLastOperation()\n        }\n    }\n    \n    private fun resetRetryCount(key: String) {\n        retryAttempts.remove(key)\n    }\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"testing-listeners",children:"Testing Listeners"}),"\n",(0,s.jsx)(n.h3,{id:"mock-flow-testing",children:"Mock Flow Testing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'class MockKmpIAP : KmpIAP {\n    private val _purchaseUpdated = MutableSharedFlow<Purchase>()\n    override val purchaseUpdatedListener: Flow<Purchase> = _purchaseUpdated\n\n    private val _purchaseError = MutableSharedFlow<PurchaseError>()\n    override val purchaseErrorListener: Flow<PurchaseError> = _purchaseError\n    \n    // Test helpers\n    suspend fun emitPurchase(purchase: Purchase) {\n        _purchaseUpdated.emit(purchase)\n    }\n    \n    suspend fun emitError(error: PurchaseError) {\n        _purchaseError.emit(error)\n    }\n}\n\n// In tests\n@Test\nfun testPurchaseListener() = runTest {\n    val mockIap = MockKmpIAP()\n    var receivedPurchase: Purchase? = null\n    \n    val job = launch {\n        mockIap.purchaseUpdatedListener.collect { purchase ->\n            receivedPurchase = purchase\n        }\n    }\n    \n    // Emit test purchase\n    val testPurchase = Purchase(\n        productId = "test_product",\n        transactionId = "12345"\n    )\n    mockIap.emitPurchase(testPurchase)\n    \n    // Verify\n    advanceUntilIdle()\n    assertEquals("test_product", receivedPurchase?.productId)\n    \n    job.cancel()\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Always collect in coroutine scope"}),": Prevent memory leaks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use lifecycle-aware collection"}),": Stop listening when UI is not visible"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handle all error types"}),": Provide appropriate user feedback"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Debounce/throttle when needed"}),": Prevent UI flooding"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clean up listeners"}),": Cancel jobs when no longer needed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Test listener behavior"}),": Mock flows for unit testing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Combine related flows"}),": Simplify complex event handling"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/kmp-iap/docs/1.0.0-rc/api/core-methods",children:"Core Methods"})," - Methods that trigger events"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/kmp-iap/docs/1.0.0-rc/api/error-codes",children:"Error Codes"})," - Complete error code reference"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/kmp-iap/docs/1.0.0-rc/examples/complete-implementation",children:"Examples"})," - Full listener implementation"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},5159:(e,n,r)=>{r.d(n,{A:()=>i});r(6540);var s=r(6025),t=r(7856),c=r(4848);function i({className:e="iapkit-banner",style:n}){const r=(0,s.A)("/img/iapkit-banner.gif");return(0,c.jsx)("div",{className:e,style:n,children:(0,c.jsx)("a",{href:t.V,target:"_blank",rel:"noopener noreferrer",onClick:async()=>{try{await fetch(t.I,{method:"POST",mode:"no-cors"})}catch(e){console.error("Failed to track banner click:",e)}},style:{display:"block",textAlign:"center",marginBottom:"20px",textDecoration:"none",cursor:"pointer"},children:(0,c.jsx)("img",{src:r,alt:"IAPKit - In-App Purchase Made Simple",style:{height:"auto",borderRadius:"8px",objectFit:"contain"}})})})}},7856:(e,n,r)=>{r.d(n,{I:()=>t,V:()=>s});const s="https://iapkit.com",t="https://www.hyo.dev/api/ad-banner/cmjf0l20n0002249hjrwmgob3"},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var s=r(6540);const t={},c=s.createContext(t);function i(e){const n=s.useContext(c);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);