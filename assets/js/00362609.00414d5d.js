"use strict";(self.webpackChunkkmp_iap_docs=self.webpackChunkkmp_iap_docs||[]).push([[7733],{1437:(e,n,i)=>{i.d(n,{A:()=>t});i(6540);var r=i(7856),s=i(4848);function t({children:e,href:n,className:i,style:t}){return(0,s.jsx)("a",{href:n||r.V,target:"_blank",rel:"noopener noreferrer",onClick:async()=>{try{await fetch(r.I,{method:"POST",mode:"no-cors"})}catch(e){console.error("Failed to track link click:",e)}},className:i,style:t,children:e})}},5159:(e,n,i)=>{i.d(n,{A:()=>a});i(6540);var r=i(6025),s=i(7856),t=i(4848);function a({className:e="iapkit-banner",style:n}){const i=(0,r.A)("/img/iapkit-banner.gif");return(0,t.jsx)("div",{className:e,style:n,children:(0,t.jsx)("a",{href:s.V,target:"_blank",rel:"noopener noreferrer",onClick:async()=>{try{await fetch(s.I,{method:"POST",mode:"no-cors"})}catch(e){console.error("Failed to track banner click:",e)}},style:{display:"block",textAlign:"center",marginBottom:"20px",textDecoration:"none",cursor:"pointer"},children:(0,t.jsx)("img",{src:i,alt:"IAPKit - In-App Purchase Made Simple",style:{height:"auto",borderRadius:"8px",objectFit:"contain"}})})})}},7856:(e,n,i)=>{i.d(n,{I:()=>s,V:()=>r});const r="https://iapkit.com",s="https://www.hyo.dev/api/ad-banner/cmjf0l20n0002249hjrwmgob3"},8063:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var r=i(4848),s=i(8453),t=i(5159),a=i(1437);const o={sidebar_position:7,title:"Lifecycle"},c="Lifecycle",l={id:"guides/lifecycle",title:"Lifecycle",description:"Understanding and managing the in-app purchase lifecycle is crucial for creating robust and reliable purchase experiences in Kotlin Multiplatform projects.",source:"@site/versioned_docs/version-1.0.0/guides/lifecycle.md",sourceDirName:"guides",slug:"/guides/lifecycle",permalink:"/kmp-iap/docs/1.0.0/guides/lifecycle",draft:!1,unlisted:!1,editUrl:"https://github.com/hyochan/kmp-iap/tree/main/docs/versioned_docs/version-1.0.0/guides/lifecycle.md",tags:[],version:"1.0.0",sidebarPosition:7,frontMatter:{sidebar_position:7,title:"Lifecycle"},sidebar:"docsSidebar",previous:{title:"Purchases",permalink:"/kmp-iap/docs/1.0.0/guides/purchases"},next:{title:"Offer Code Redemption",permalink:"/kmp-iap/docs/1.0.0/guides/offer-code-redemption"}},d={},u=[{value:"Lifecycle Overview",id:"lifecycle-overview",level:2},{value:"Connection Management with KmpIAP",id:"connection-management-with-kmpiap",level:2},{value:"Automatic Connection",id:"automatic-connection",level:3},{value:"Connection States",id:"connection-states",level:3},{value:"Component Lifecycle Integration",id:"component-lifecycle-integration",level:2},{value:"ViewModel Integration",id:"viewmodel-integration",level:3},{value:"Compose Integration",id:"compose-integration",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"\u2705 Do",id:"-do",level:3},{value:"\u274c Don&#39;t",id:"-dont",level:3},{value:"Purchase Flow Best Practices",id:"purchase-flow-best-practices",level:2},{value:"Receipt Validation and Security",id:"receipt-validation-and-security",level:3},{value:"Purchase State Management",id:"purchase-state-management",level:3},{value:"Error Handling and User Experience",id:"error-handling-and-user-experience",level:2},{value:"Comprehensive Error Handling",id:"comprehensive-error-handling",level:3},{value:"Testing and Development",id:"testing-and-development",level:2},{value:"Development Environment Setup",id:"development-environment-setup",level:3},{value:"Common Pitfalls and Solutions",id:"common-pitfalls-and-solutions",level:2},{value:"Transaction Management Issues",id:"transaction-management-issues",level:3},{value:"Security Issues",id:"security-issues",level:3},{value:"Development and Testing Issues",id:"development-and-testing-issues",level:3},{value:"App Lifecycle Issues",id:"app-lifecycle-issues",level:3},{value:"Connection Management Issues",id:"connection-management-issues",level:3},{value:"Next Steps",id:"next-steps",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"lifecycle",children:"Lifecycle"}),"\n",(0,r.jsx)(t.A,{}),"\n",(0,r.jsx)(n.p,{children:"Understanding and managing the in-app purchase lifecycle is crucial for creating robust and reliable purchase experiences in Kotlin Multiplatform projects."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://www.openiap.dev/purchase-flow.png",alt:"Purchase Lifecycle"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.em,{children:["Learn more about the OpenIAP lifecycle specification: ",(0,r.jsx)(n.a,{href:"https://www.openiap.dev/docs/lifecycle",children:"OpenIAP Lifecycle Documentation"})]})}),"\n",(0,r.jsx)(n.p,{children:"The purchase lifecycle involves multiple interconnected states and transitions, from initial store connection through purchase completion and transaction finalization. Understanding this flow helps you build resilient purchase systems that handle edge cases gracefully."}),"\n",(0,r.jsx)(n.h2,{id:"lifecycle-overview",children:"Lifecycle Overview"}),"\n",(0,r.jsx)(n.p,{children:"The in-app purchase lifecycle consists of several key phases:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Store Connection"})," - Establishing connection with platform stores"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Product Loading"})," - Fetching available products and pricing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Purchase Initiation"})," - User-triggered purchase requests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transaction Processing"})," - Platform-handled payment flow"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Purchase Completion"})," - Successful transaction receipt"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Content Delivery"})," - Providing purchased content to user"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transaction Finalization"})," - Consuming/acknowledging purchases"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Each phase has its own requirements and potential failure modes that need proper handling."}),"\n",(0,r.jsx)(n.h2,{id:"connection-management-with-kmpiap",children:"Connection Management with KmpIAP"}),"\n",(0,r.jsx)(n.h3,{id:"automatic-connection",children:"Automatic Connection"}),"\n",(0,r.jsx)(n.p,{children:"The kmp-iap library supports both instance creation and singleton patterns. Here's an example using the instance pattern:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport io.github.hyochan.kmpiap.*\nimport io.github.hyochan.kmpiap.types.*\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\n\nclass IAPViewModel : ViewModel() {\n    private val kmpIap = KmpIAP()\n    \n    data class ConnectionState(\n        val isConnected: Boolean = false,\n        val isLoading: Boolean = false,\n        val error: String? = null\n    )\n    \n    private val _connectionState = MutableStateFlow(ConnectionState())\n    val connectionState: StateFlow<ConnectionState> = _connectionState.asStateFlow()\n    \n    init {\n        // Automatically initialize connection when ViewModel is created\n        initConnection()\n        observePurchaseEvents()\n    }\n    \n    private fun initConnection() {\n        viewModelScope.launch {\n            _connectionState.update { it.copy(isLoading = true, error = null) }\n            \n            try {\n                val connected = kmpIap.initConnection()\n                _connectionState.update { \n                    it.copy(\n                        isConnected = connected,\n                        isLoading = false\n                    )\n                }\n            } catch (e: PurchaseError) {\n                _connectionState.update { \n                    it.copy(\n                        error = e.message,\n                        isLoading = false,\n                        isConnected = false\n                    )\n                }\n            }\n        }\n    }\n    \n    private fun observePurchaseEvents() {\n        viewModelScope.launch {\n            kmpIap.purchaseErrorListener.collect { error ->\n                _connectionState.update { \n                    it.copy(error = error.message)\n                }\n            }\n        }\n    }\n    \n    override fun onCleared() {\n        super.onCleared()\n        kmpIap.dispose()\n    }\n"})}),"\n",(0,r.jsx)(n.h3,{id:"connection-states",children:"Connection States"}),"\n",(0,r.jsx)(n.p,{children:"Monitor connection states to provide appropriate user feedback:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"enum class IAPConnectionState {\n    DISCONNECTED,\n    CONNECTING,\n    CONNECTED,\n    ERROR\n}\n\nclass ConnectionManager(\n    private val scope: CoroutineScope\n) {\n    // Initialize KmpIAP in init block\n    \n    private val _state = MutableStateFlow(IAPConnectionState.DISCONNECTED)\n    val state: StateFlow<IAPConnectionState> = _state.asStateFlow()\n    \n    private var _errorMessage: String? = null\n    val errorMessage: String? get() = _errorMessage\n    \n    suspend fun connect() {\n        _state.value = IAPConnectionState.CONNECTING\n        \n        try {\n            KmpIAP.initConnection()\n            // Observe connection state\n            scope.launch {\n                val connected = KmpIAP.isConnected()\n                    _state.value = if (connected) {\n                        IAPConnectionState.CONNECTED\n                    } else {\n                        IAPConnectionState.DISCONNECTED\n                    }\n                }\n            }\n        } catch (e: PurchaseError) {\n            _state.value = IAPConnectionState.ERROR\n            _errorMessage = e.message\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"component-lifecycle-integration",children:"Component Lifecycle Integration"}),"\n",(0,r.jsx)(n.h3,{id:"viewmodel-integration",children:"ViewModel Integration"}),"\n",(0,r.jsx)(n.p,{children:"Integrate IAP lifecycle with Android ViewModel:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"import androidx.lifecycle.*\nimport kotlinx.coroutines.flow.*\n\nclass PurchaseViewModel : ViewModel() {\n    // KmpIAP is a singleton, no need to create instance\n    \n    data class PurchaseUiState(\n        val isProcessing: Boolean = false,\n        val products: List<Product> = emptyList(),\n        val currentPurchase: Purchase? = null,\n        val error: PurchaseError? = null\n    )\n    \n    private val kmpIap = KmpIAP()\n    private val _uiState = MutableStateFlow(PurchaseUiState())\n    val uiState: StateFlow<PurchaseUiState> = _uiState.asStateFlow()\n    \n    init {\n        setupPurchaseObservers()\n        viewModelScope.launch {\n            val connected = kmpIap.initConnection()\n            if (connected) {\n                checkPendingPurchases()\n            }\n        }\n    }\n    \n    private fun setupPurchaseObservers() {\n        // Observe purchase success\n        viewModelScope.launch {\n            kmpIap.purchaseUpdatedListener.collect { purchase ->\n                purchase?.let {\n                    _uiState.update { state ->\n                        state.copy(\n                            isProcessing = false,\n                            currentPurchase = it\n                        )\n                    }\n                    handlePurchaseSuccess(it)\n                }\n            }\n        }\n        \n        // Observe errors\n        viewModelScope.launch {\n            kmpIap.purchaseErrorListener.collect { error ->\n                error?.let {\n                    _uiState.update { state ->\n                        state.copy(\n                            isProcessing = false,\n                            error = it\n                        )\n                    }\n                    handlePurchaseError(it)\n                }\n            }\n        }\n    }\n    \n    private suspend fun checkPendingPurchases() {\n        // Check for pending transactions on app resume\n        val purchases = KmpIAP.getAvailablePurchases()\n            purchases.forEach { purchase ->\n                if (!isTransactionFinished(purchase)) {\n                    finishPendingTransaction(purchase)\n                }\n            }\n        }\n    }\n    \n    override fun onCleared() {\n        super.onCleared()\n        kmpIap.dispose()\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"compose-integration",children:"Compose Integration"}),"\n",(0,r.jsx)(n.p,{children:"Using IAP with Jetpack Compose and lifecycle awareness:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"import androidx.compose.runtime.*\nimport androidx.compose.ui.platform.LocalLifecycleOwner\nimport androidx.lifecycle.Lifecycle\nimport androidx.lifecycle.LifecycleEventObserver\n\n@Composable\nfun PurchaseScreen(viewModel: PurchaseViewModel = viewModel()) {\n    val lifecycleOwner = LocalLifecycleOwner.current\n    val uiState by viewModel.uiState.collectAsState()\n    \n    // Handle lifecycle events\n    DisposableEffect(lifecycleOwner) {\n        val observer = LifecycleEventObserver { _, event ->\n            when (event) {\n                Lifecycle.Event.ON_RESUME -> {\n                    // App resumed - check for pending purchases\n                    viewModel.checkPendingPurchases()\n                }\n                Lifecycle.Event.ON_PAUSE -> {\n                    // App paused - save any pending state\n                    viewModel.savePendingState()\n                }\n                else -> {}\n            }\n        }\n        \n        lifecycleOwner.lifecycle.addObserver(observer)\n        \n        onDispose {\n            lifecycleOwner.lifecycle.removeObserver(observer)\n        }\n    }\n    \n    // UI content\n    PurchaseContent(\n        uiState = uiState,\n        onPurchase = viewModel::purchaseProduct\n    )\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"-do",children:"\u2705 Do"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Initialize connections early"})," in your app lifecycle"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Set up state observers"})," before making any purchase requests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Handle app state changes"})," (background/foreground transitions)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement retry logic"})," for failed connections"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clean up resources"})," properly in onCleared/dispose methods"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Check for pending purchases"})," when app resumes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validate purchases server-side"})," for security"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Provide user feedback"})," during purchase processing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Handle network interruptions"})," gracefully"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test on different devices"})," and OS versions"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"// Good: Comprehensive lifecycle management\nclass GoodPurchaseManager : ViewModel() {\n    // KmpIAP is a singleton\n    \n    init {\n        setupObservers()\n        ensureConnection()\n    }\n    \n    private fun ensureConnection() {\n        viewModelScope.launch {\n            val connected = KmpIAP.isConnected()\n            if (!connected) {\n                scheduleReconnection()\n            }\n        }\n    }\n    \n    fun checkPendingTransactions() {\n        viewModelScope.launch {\n            val purchases = KmpIAP.getAvailablePurchases()\n            purchases.forEach { finishIfNeeded(it) }\n        }\n    }\n    \n    override fun onCleared() {\n        super.onCleared()\n        kmpIap.dispose()\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"-dont",children:"\u274c Don't"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Make purchases without observers"})," set up first"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ignore connection state"})," when making requests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Block UI indefinitely"})," during purchase processing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Store sensitive data"})," in local storage"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trust client-side validation"})," alone"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Forget to handle edge cases"})," (network issues, app backgrounding)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Leave connections open"})," when not needed"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Assume purchases complete immediately"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Skip testing"})," in sandbox environments"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Ignore platform differences"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"// Bad: No lifecycle management\nclass BadPurchaseManager {\n    fun makePurchase(productId: String) {\n        // Bad: No connection check\n        // Bad: No observers set up\n        // Bad: No error handling\n        GlobalScope.launch {\n            kmpIapInstance.requestPurchase {\n                ios { sku = productId }\n                android { skus = listOf(productId) }\n            }\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"purchase-flow-best-practices",children:"Purchase Flow Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"receipt-validation-and-security",children:"Receipt Validation and Security"}),"\n",(0,r.jsx)(n.p,{children:"Always validate purchases server-side. The validation methods shown below must be implemented by you on your backend - kmp-iap provides the purchase data, but server-side validation is your responsibility:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'// NOTE: The `api` object and its methods (validateIOSReceipt, validateAndroidPurchase)\n// are YOUR backend API client - not provided by kmp-iap.\n// You must implement these endpoints on your server.\n\nclass SecurePurchaseValidator(\n    private val api: YourBackendApi // Your backend API client\n) {\n    suspend fun validatePurchase(purchase: Purchase): Boolean {\n        return try {\n            when (getCurrentPlatform()) {\n                IapPlatform.Ios -> {\n                    // iOS receipt validation - call YOUR backend\n                    val result = api.validateIOSReceipt(\n                        receipt = purchase.transactionReceipt ?: "",\n                        isProduction = !BuildConfig.DEBUG\n                    )\n\n                    result.isValid\n                }\n                IapPlatform.Android -> {\n                    // Android purchase validation - call YOUR backend\n                    val result = api.validateAndroidPurchase(\n                        packageName = BuildConfig.APPLICATION_ID,\n                        productId = purchase.productId,\n                        purchaseToken = purchase.purchaseToken ?: "",\n                        isSubscription = false\n                    )\n\n                    result.isValid\n                }\n            }\n        } catch (e: Exception) {\n            println("Validation failed: $e")\n            false\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.admonition,{title:"Using IAPKit for Verification",type:"tip",children:(0,r.jsxs)(n.p,{children:["Instead of implementing your own backend, you can use ",(0,r.jsx)(a.A,{children:"IAPKit"})," with ",(0,r.jsx)(n.code,{children:"verifyPurchaseWithProvider()"})," for hassle-free server-side verification."]})}),"\n",(0,r.jsx)(n.h3,{id:"purchase-state-management",children:"Purchase State Management"}),"\n",(0,r.jsx)(n.p,{children:"Track purchase states throughout the lifecycle:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'enum class PurchaseFlowState {\n    IDLE,\n    LOADING,\n    PROCESSING,\n    VALIDATING,\n    DELIVERING,\n    COMPLETED,\n    ERROR\n}\n\nclass PurchaseStateManager(\n    private val scope: CoroutineScope\n) {\n    private val _state = MutableStateFlow(PurchaseFlowState.IDLE)\n    val state: StateFlow<PurchaseFlowState> = _state.asStateFlow()\n    \n    private var _currentProductId: String? = null\n    private var _errorMessage: String? = null\n    \n    val currentProductId: String? get() = _currentProductId\n    val errorMessage: String? get() = _errorMessage\n    \n    suspend fun initiatePurchase(productId: String) {\n        updateState(PurchaseFlowState.LOADING, productId)\n        \n        try {\n            // Check connection\n            if (!KmpIAP.isConnected()) {\n                throw PurchaseError(\n                    code = ErrorCode.SERVICE_DISCONNECTED,\n                    message = "Store connection lost"\n                )\n            }\n            \n            updateState(PurchaseFlowState.PROCESSING, productId)\n\n            kmpIapInstance.requestPurchase {\n                ios {\n                    sku = productId\n                    quantity = 1\n                }\n                android {\n                    skus = listOf(productId)\n                    obfuscatedAccountId = getUserId()\n                }\n            }\n            \n        } catch (e: PurchaseError) {\n            updateState(\n                PurchaseFlowState.ERROR,\n                productId,\n                e.message\n            )\n        }\n    }\n    \n    private fun updateState(\n        newState: PurchaseFlowState,\n        productId: String? = null,\n        error: String? = null\n    ) {\n        _state.value = newState\n        _currentProductId = productId\n        _errorMessage = error\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling-and-user-experience",children:"Error Handling and User Experience"}),"\n",(0,r.jsx)(n.h3,{id:"comprehensive-error-handling",children:"Comprehensive Error Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'import androidx.compose.material3.*\nimport androidx.compose.runtime.*\n\nclass PurchaseErrorHandler {\n    fun handlePurchaseError(\n        error: PurchaseError,\n        snackbarHostState: SnackbarHostState,\n        scope: CoroutineScope\n    ) {\n        val (message, actionLabel) = when (error.code) {\n            ErrorCode.UserCancelled -> {\n                // User cancelled - no message needed\n                return\n            }\n            ErrorCode.NetworkError -> {\n                "Network error. Please check your connection." to "Retry"\n            }\n            ErrorCode.ServiceError -> {\n                "Store service unavailable. Please try later." to null\n            }\n            ErrorCode.ItemUnavailable -> {\n                "This item is currently unavailable" to null\n            }\n            ErrorCode.DeveloperError -> {\n                "Configuration error. Please update the app." to null\n            }\n            ErrorCode.AlreadyOwned -> {\n                "You already own this item" to "Restore"\n            }\n            else -> {\n                "Purchase failed: ${error.message}" to null\n            }\n        }\n\n        scope.launch {\n            val result = snackbarHostState.showSnackbar(\n                message = message,\n                actionLabel = actionLabel,\n                duration = SnackbarDuration.Long\n            )\n\n            if (result == SnackbarResult.ActionPerformed) {\n                when (error.code) {\n                    ErrorCode.NetworkError -> retryLastPurchase()\n                    ErrorCode.AlreadyOwned -> restorePurchases()\n                    else -> {}\n                }\n            }\n        }\n    }\n    \n    private suspend fun retryLastPurchase() {\n        // Implement retry logic\n    }\n    \n    private suspend fun restorePurchases() {\n        // Implement restore logic\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"testing-and-development",children:"Testing and Development"}),"\n",(0,r.jsx)(n.h3,{id:"development-environment-setup",children:"Development Environment Setup"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'object DevelopmentHelpers {\n    val isDebugMode = BuildConfig.DEBUG\n    \n    suspend fun setupTestEnvironment() {\n        if (!isDebugMode) return\n        \n        // Clear any existing transactions in debug mode\n        try {\n            println("Setting up test environment...")\n            // Test products will be loaded\n        } catch (e: Exception) {\n            println("Failed to setup test environment: $e")\n        }\n    }\n    \n    fun logPurchaseState(state: String, data: Map<String, Any?>? = null) {\n        if (!isDebugMode) return\n        \n        println("Purchase State: $state")\n        data?.forEach { (key, value) ->\n            println("  $key: $value")\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"common-pitfalls-and-solutions",children:"Common Pitfalls and Solutions"}),"\n",(0,r.jsx)(n.h3,{id:"transaction-management-issues",children:"Transaction Management Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Purchases getting stuck in pending state"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'// Solution: Implement proper transaction cleanup\nclass TransactionCleanup(\n    private val scope: CoroutineScope\n) {\n    suspend fun cleanupPendingTransactions() {\n        try {\n            // Get all available purchases\n            KmpIAP.getAvailablePurchases().forEach { purchase ->\n                finalizePurchase(purchase)\n            }\n        } catch (e: Exception) {\n            println("Error cleaning up transactions: $e")\n        }\n    }\n    \n    private suspend fun finalizePurchase(purchase: Purchase) {\n        // Validate and deliver content first\n        val isValid = validatePurchase(purchase)\n        if (!isValid) return\n        \n        deliverContent(purchase)\n        \n        // Then finalize the transaction\n        val success = KmpIAP.finishTransaction(\n            purchase = purchase,\n            isConsumable = isConsumable(purchase.productId)\n        )\n        \n        if (success) {\n            println("Transaction finalized: ${purchase.productId}")\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"security-issues",children:"Security Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Client-side only validation"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"// Solution: Always validate server-side\nclass SecurityBestPractices {\n    suspend fun secureValidation(purchase: Purchase): Boolean {\n        // 1. Client-side basic checks\n        if (purchase.productId.isEmpty() || \n            purchase.transactionReceipt == null) {\n            return false\n        }\n        \n        // 2. Server-side validation (critical)\n        val serverValid = validateWithServer(purchase)\n        if (!serverValid) return false\n        \n        // 3. Business logic validation\n        val businessValid = validateBusinessRules(purchase)\n        \n        return businessValid\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"development-and-testing-issues",children:"Development and Testing Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Different behavior in sandbox vs production"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'// Solution: Environment-aware configuration\nobject EnvironmentConfig {\n    val isProduction = !BuildConfig.DEBUG && isProductionBuild()\n    val isSandbox = BuildConfig.DEBUG || isSandboxBuild()\n    \n    val validationEndpoint: String\n        get() = if (isProduction) {\n            "https://buy.itunes.apple.com/verifyReceipt"\n        } else {\n            "https://sandbox.itunes.apple.com/verifyReceipt"\n        }\n    \n    private fun isProductionBuild(): Boolean {\n        // Add your production detection logic\n        return false\n    }\n    \n    private fun isSandboxBuild(): Boolean {\n        // Add your sandbox detection logic  \n        return true\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"app-lifecycle-issues",children:"App Lifecycle Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Purchases interrupted by app backgrounding"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"// Solution: Implement proper app lifecycle handling\nclass LifecycleAwarePurchaseManager(\n    private val scope: CoroutineScope\n) {\n    private val pendingPurchases = mutableMapOf<String, PurchaseFlowState>()\n    // Initialize KmpIAP in init block\n    \n    fun onAppResumed() {\n        resumePendingPurchases()\n    }\n    \n    fun onAppPaused() {\n        savePendingPurchases()\n    }\n    \n    private fun resumePendingPurchases() {\n        // Check for any purchases that completed while app was backgrounded\n        scope.launch {\n            val purchases = KmpIAP.getAvailablePurchases()\n                purchases.forEach { purchase ->\n                    if (pendingPurchases.containsKey(purchase.productId)) {\n                        finalizePurchase(purchase)\n                    }\n                }\n            }\n        }\n    }\n    \n    private fun savePendingPurchases() {\n        // Persist pending purchase state\n        // This helps recover from app kills during purchase\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"connection-management-issues",children:"Connection Management Issues"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Connection drops during purchase flow"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'// Solution: Implement connection resilience\nclass ResilientConnectionManager(\n    private val scope: CoroutineScope\n) {\n    suspend fun ensureConnectionWithRetry(): Boolean {\n        repeat(3) { attempt ->\n            try {\n                KmpIAP.initConnection()\n                return true\n            } catch (e: PurchaseError) {\n                println("Connection attempt ${attempt + 1} failed: $e")\n                \n                if (attempt < 2) {\n                    delay(2000L * (attempt + 1))\n                }\n            }\n        }\n        \n        return false\n    }\n    \n    init {\n        // Check connection and retry if needed\n        scope.launch {\n            val connected = KmpIAP.isConnected()\n            if (!connected) {\n                ensureConnectionWithRetry()\n            }\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(n.p,{children:"After implementing proper lifecycle management:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test thoroughly"})," in both sandbox and production environments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitor purchase analytics"})," to identify lifecycle issues"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement proper logging"})," for debugging purchase flows"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Set up alerts"})," for purchase failures and anomalies"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Review and optimize"})," purchase success rates"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consider advanced features"})," like promotional offers and subscription management"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For more detailed guidance on specific purchase flows, see:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/kmp-iap/docs/1.0.0/guides/purchases",children:"Purchases Guide"})," - Complete purchase implementation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/kmp-iap/docs/1.0.0/guides/offer-code-redemption",children:"Offer Code Redemption"})," - Promotional offers"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/kmp-iap/docs/1.0.0/guides/troubleshooting",children:"Troubleshooting"})," - Common issues and solutions"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var r=i(6540);const s={},t=r.createContext(s);function a(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);