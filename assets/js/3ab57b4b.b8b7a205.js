"use strict";(self.webpackChunkkmp_iap_docs=self.webpackChunkkmp_iap_docs||[]).push([[45],{3679:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>c,toc:()=>p});var t=i(4848),r=i(8453),o=i(5159);const s={sidebar_position:2,title:"Subscription Store"},a="Subscription Store Example",c={id:"examples/subscription-store",title:"Subscription Store",description:"A complete subscription store implementation with monthly and yearly plans using kmp-iap.",source:"@site/versioned_docs/version-1.0.0-beta/examples/subscription-store.md",sourceDirName:"examples",slug:"/examples/subscription-store",permalink:"/kmp-iap/docs/1.0.0-beta/examples/subscription-store",draft:!1,unlisted:!1,editUrl:"https://github.com/hyochan/kmp-iap/tree/main/docs/versioned_docs/version-1.0.0-beta/examples/subscription-store.md",tags:[],version:"1.0.0-beta",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Subscription Store"},sidebar:"docsSidebar",previous:{title:"Basic Store",permalink:"/kmp-iap/docs/1.0.0-beta/examples/basic-store"},next:{title:"Complete Implementation",permalink:"/kmp-iap/docs/1.0.0-beta/examples/complete-implementation"}},l={},p=[{value:"Features",id:"features",level:2},{value:"Complete Implementation",id:"complete-implementation",level:2},{value:"Key Features Explained",id:"key-features-explained",level:2},{value:"1. Subscription Grouping",id:"1-subscription-grouping",level:3},{value:"2. Status Display",id:"2-status-display",level:3},{value:"3. Visual Hierarchy",id:"3-visual-hierarchy",level:3},{value:"4. Android Subscription Offers",id:"4-android-subscription-offers",level:3},{value:"Best Practices Implemented",id:"best-practices-implemented",level:2},{value:"Enhanced Subscription Management Features",id:"enhanced-subscription-management-features",level:2},{value:"Using New ActiveSubscription APIs",id:"using-new-activesubscription-apis",level:3},{value:"Platform-Specific Subscription Details",id:"platform-specific-subscription-details",level:3},{value:"iOS Features",id:"ios-features",level:4},{value:"Android Features",id:"android-features",level:4},{value:"Visual Subscription Status",id:"visual-subscription-status",level:3},{value:"Legacy Subscription Status Check",id:"legacy-subscription-status-check",level:3},{value:"Handling Grace Periods",id:"handling-grace-periods",level:3},{value:"Testing Considerations",id:"testing-considerations",level:2},{value:"Platform-Specific Features",id:"platform-specific-features",level:2},{value:"iOS Promotional Offers",id:"ios-promotional-offers",level:3},{value:"Android Subscription Management",id:"android-subscription-management",level:3}];function u(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h1,{id:"subscription-store-example",children:"Subscription Store Example"}),"\n",(0,t.jsx)(o.A,{}),"\n",(0,t.jsx)(e.p,{children:"A complete subscription store implementation with monthly and yearly plans using kmp-iap."}),"\n",(0,t.jsx)(e.h2,{id:"features",children:"Features"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Multiple subscription tiers"}),"\n",(0,t.jsx)(e.li,{children:"Subscription status display"}),"\n",(0,t.jsx)(e.li,{children:"Automatic renewal handling"}),"\n",(0,t.jsx)(e.li,{children:"Restore purchases"}),"\n",(0,t.jsx)(e.li,{children:"Grace period support"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"complete-implementation",children:"Complete Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'import androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport io.github.hyochan.kmpiap.KmpIAP\nimport io.github.hyochan.kmpiap.data.*\nimport io.github.hyochan.kmpiap.openiap.IapPlatform\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.launch\nimport kotlinx.datetime.*\n\nclass SubscriptionStoreViewModel : ViewModel() {\n    \n    // State management\n    data class SubscriptionState(\n        val isConnected: Boolean = false,\n        val isLoading: Boolean = false,\n        val subscriptions: List<Product> = emptyList(),\n        val activeSubscriptions: List<ActiveSubscription> = emptyList(),\n        val hasActiveSubscription: Boolean = false,\n        val error: String? = null\n    )\n    \n    private val _state = MutableStateFlow(SubscriptionState())\n    val state: StateFlow<SubscriptionState> = _state.asStateFlow()\n    \n    // Your subscription IDs\n    private val subscriptionIds = listOf(\n        "premium_monthly",\n        "premium_yearly",\n        "pro_monthly",\n        "pro_yearly"\n    )\n    \n    init {\n        initializeStore()\n        observeStates()\n    }\n    \n    private fun initializeStore() {\n        viewModelScope.launch {\n            _state.update { it.copy(isLoading = true, error = null) }\n            \n            try {\n                KmpIAP.initConnection()\n                loadSubscriptions()\n            } catch (e: PurchaseError) {\n                showError("Failed to initialize store: ${e.message}")\n            }\n        }\n    }\n    \n    private fun observeStates() {\n        // Observe connection\n        viewModelScope.launch {\n            KmpIAP.isConnected.collectLatest { connected ->\n                _state.update { it.copy(isConnected = connected) }\n            }\n        }\n        \n        // Observe subscriptions\n        viewModelScope.launch {\n            KmpIAP.subscriptions.collectLatest { subs ->\n                _state.update { it.copy(subscriptions = subs) }\n            }\n        }\n        \n        // Observe active subscriptions using new API\n        viewModelScope.launch {\n            // Check for active subscriptions periodically or when state changes\n            loadActiveSubscriptions()\n        }\n        \n        // Observe purchase updates\n        viewModelScope.launch {\n            KmpIAP.currentPurchase.collectLatest { purchase ->\n                purchase?.let { handlePurchaseUpdate(it) }\n            }\n        }\n        \n        // Observe errors\n        viewModelScope.launch {\n            KmpIAP.currentError.collectLatest { error ->\n                error?.let {\n                    handlePurchaseError(it)\n                    KmpIAP.clearError()\n                }\n            }\n        }\n    }\n    \n    private suspend fun loadSubscriptions() {\n        _state.update { it.copy(isLoading = true, error = null) }\n        \n        try {\n            val subscriptions = KmpIAP.getSubscriptions(subscriptionIds)\n            println("Loaded ${subscriptions.size} subscriptions")\n            \n            // Also load active subscriptions\n            loadActiveSubscriptions()\n        } catch (e: PurchaseError) {\n            showError("Failed to load subscriptions: ${e.message}")\n        } finally {\n            _state.update { it.copy(isLoading = false) }\n        }\n    }\n    \n    private suspend fun loadActiveSubscriptions() {\n        try {\n            // Use new APIs to get active subscription information\n            val activeSubscriptions = kmpIapInstance.getActiveSubscriptions(subscriptionIds)\n            val hasActiveSubscription = kmpIapInstance.hasActiveSubscriptions(subscriptionIds)\n            \n            _state.update { \n                it.copy(\n                    activeSubscriptions = activeSubscriptions,\n                    hasActiveSubscription = hasActiveSubscription\n                ) \n            }\n            \n            println("Found ${activeSubscriptions.size} active subscriptions")\n            activeSubscriptions.forEach { subscription ->\n                println("Active subscription: ${subscription.productId}")\n                \n                // iOS-specific information\n                subscription.expirationDateIOS?.let { expDate ->\n                    val expirationDate = Instant.fromEpochMilliseconds(expDate)\n                    println("  Expires: $expirationDate")\n                }\n                subscription.environmentIOS?.let { env ->\n                    println("  Environment: $env")\n                }\n                subscription.daysUntilExpirationIOS?.let { days ->\n                    println("  Days until expiration: $days")\n                }\n                \n                // Android-specific information\n                subscription.autoRenewingAndroid?.let { autoRenew ->\n                    println("  Auto-renewing: $autoRenew")\n                }\n                \n                // Cross-platform warnings\n                if (subscription.willExpireSoon == true) {\n                    println("  \u26a0\ufe0f This subscription will expire soon!")\n                }\n            }\n        } catch (e: Exception) {\n            showError("Failed to load active subscriptions: ${e.message}")\n        }\n    }\n    \n    private suspend fun handlePurchaseUpdate(purchase: Purchase) {\n        println("Purchase update: ${purchase.productId}")\n        \n        try {\n            // Verify purchase on your server\n            val isValid = verifyPurchase(purchase)\n            \n            if (isValid) {\n                // Deliver subscription access\n                deliverSubscription(purchase)\n                \n                // Complete transaction\n                completeTransaction(purchase)\n                \n                // Reload active subscriptions to reflect changes\n                loadActiveSubscriptions()\n                \n                // Clear current purchase\n                KmpIAP.clearPurchase()\n                \n                showMessage("Subscription activated!")\n            } else {\n                showError("Purchase verification failed")\n            }\n        } catch (e: Exception) {\n            showError("Failed to process purchase: ${e.message}")\n        }\n    }\n    \n    private fun handlePurchaseError(error: PurchaseError) {\n        when (error.code) {\n            ErrorCode.USER_CANCELLED -> {\n                // Silent - user cancelled\n            }\n            ErrorCode.PRODUCT_ALREADY_OWNED -> {\n                showMessage("You already have an active subscription")\n            }\n            else -> {\n                showError("Purchase failed: ${error.message}")\n            }\n        }\n    }\n    \n    fun requestSubscription(productId: String) {\n        viewModelScope.launch {\n            try {\n                // For Android, you might want to handle subscription offers\n                if (KmpIAP.getCurrentPlatform() == IapPlatform.ANDROID) {\n                    // Get available offers for the subscription\n                    val product = _state.value.subscriptions.find { it.productId == productId }\n                    val offers = product?.subscriptionOffers\n                    \n                    if (!offers.isNullOrEmpty()) {\n                        // Use the first offer (you might want to let user choose)\n                        KmpIAP.requestSubscription(\n                            sku = productId,\n                            subscriptionOffers = listOf(\n                                SubscriptionOfferAndroid(\n                                    sku = productId,\n                                    offerToken = offers.first().offerToken\n                                )\n                            )\n                        )\n                    } else {\n                        KmpIAP.requestSubscription(sku = productId)\n                    }\n                } else {\n                    // iOS doesn\'t need offer tokens\n                    KmpIAP.requestSubscription(sku = productId)\n                }\n            } catch (e: PurchaseError) {\n                showError("Failed to request subscription: ${e.message}")\n            }\n        }\n    }\n    \n    fun restorePurchases() {\n        viewModelScope.launch {\n            _state.update { it.copy(isLoading = true, error = null) }\n            \n            try {\n                // Get available purchases - this automatically refreshes\n                val purchases = KmpIAP.availablePurchases.value\n                val activeCount = purchases.count { \n                    subscriptionIds.contains(it.productId) && isSubscriptionActive(it)\n                }\n                \n                showMessage("Restored $activeCount active subscriptions")\n            } catch (e: PurchaseError) {\n                showError("Failed to restore purchases: ${e.message}")\n            } finally {\n                _state.update { it.copy(isLoading = false) }\n            }\n        }\n    }\n    \n    private suspend fun verifyPurchase(purchase: Purchase): Boolean {\n        // TODO: Implement server-side verification\n        // This should verify the receipt with your backend\n        return true\n    }\n    \n    private fun deliverSubscription(purchase: Purchase) {\n        // TODO: Grant subscription access to user\n        println("Delivering subscription: ${purchase.productId}")\n    }\n    \n    private suspend fun completeTransaction(purchase: Purchase) {\n        val success = KmpIAP.finishTransaction(\n            purchase = purchase,\n            isConsumable = false // Subscriptions are non-consumable\n        )\n        \n        if (success) {\n            println("Transaction completed successfully")\n        }\n    }\n    \n    private fun isSubscriptionActive(purchase: Purchase): Boolean {\n        // For a real implementation, check expiration date\n        // This is a simplified version\n        return when (purchase.purchaseState) {\n            PurchaseState.PURCHASED -> true\n            PurchaseState.PENDING -> true // Show as active during pending\n            else -> false\n        }\n    }\n    \n    fun getSubscriptionTier(productId: String): String {\n        return when {\n            productId.contains("premium") -> "Premium"\n            productId.contains("pro") -> "Pro"\n            else -> "Basic"\n        }\n    }\n    \n    fun getSubscriptionPeriod(productId: String): String {\n        return when {\n            productId.contains("monthly") -> "Monthly"\n            productId.contains("yearly") -> "Yearly"\n            else -> ""\n        }\n    }\n    \n    fun getTierColor(tier: String): Color {\n        return when (tier.lowercase()) {\n            "premium" -> Color(0xFFFFA726) // Orange\n            "pro" -> Color(0xFF9C27B0) // Purple\n            else -> Color(0xFF2196F3) // Blue\n        }\n    }\n    \n    private fun showError(message: String) {\n        _state.update { it.copy(error = message) }\n    }\n    \n    private fun showMessage(message: String) {\n        // In a real app, show a snackbar\n        println("\u2139\ufe0f $message")\n    }\n    \n    fun clearError() {\n        _state.update { it.copy(error = null) }\n    }\n    \n    override fun onCleared() {\n        super.onCleared()\n        KmpIAP.dispose()\n    }\n}\n\n@Composable\nfun SubscriptionStoreScreen(\n    viewModel: SubscriptionStoreViewModel = viewModel()\n) {\n    val state by viewModel.state.collectAsState()\n    \n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = { Text("Premium Subscriptions") },\n                actions = {\n                    IconButton(\n                        onClick = viewModel::restorePurchases,\n                        enabled = !state.isLoading\n                    ) {\n                        Icon(\n                            Icons.Default.Restore,\n                            contentDescription = "Restore Purchases"\n                        )\n                    }\n                }\n            )\n        }\n    ) { paddingValues ->\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(paddingValues)\n        ) {\n            when {\n                state.isLoading && state.subscriptions.isEmpty() -> {\n                    CircularProgressIndicator(\n                        modifier = Modifier.align(Alignment.Center)\n                    )\n                }\n                else -> {\n                    SubscriptionPlans(\n                        state = state,\n                        viewModel = viewModel\n                    )\n                }\n            }\n            \n            // Error banner\n            state.error?.let { error ->\n                Surface(\n                    modifier = Modifier.fillMaxWidth(),\n                    color = MaterialTheme.colorScheme.errorContainer\n                ) {\n                    Row(\n                        modifier = Modifier.padding(16.dp),\n                        verticalAlignment = Alignment.CenterVertically\n                    ) {\n                        Icon(\n                            Icons.Default.Error,\n                            contentDescription = null,\n                            tint = MaterialTheme.colorScheme.onErrorContainer\n                        )\n                        Spacer(modifier = Modifier.width(8.dp))\n                        Text(\n                            text = error,\n                            modifier = Modifier.weight(1f),\n                            color = MaterialTheme.colorScheme.onErrorContainer\n                        )\n                        IconButton(onClick = viewModel::clearError) {\n                            Icon(\n                                Icons.Default.Close,\n                                contentDescription = "Dismiss",\n                                tint = MaterialTheme.colorScheme.onErrorContainer\n                            )\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun SubscriptionPlans(\n    state: SubscriptionStoreViewModel.SubscriptionState,\n    viewModel: SubscriptionStoreViewModel\n) {\n    // Group subscriptions by tier\n    val groupedSubs = state.subscriptions.groupBy { \n        viewModel.getSubscriptionTier(it.productId) \n    }\n    \n    LazyColumn(\n        contentPadding = PaddingValues(16.dp),\n        verticalArrangement = Arrangement.spacedBy(16.dp)\n    ) {\n        // Current Status\n        item {\n            CurrentSubscriptionStatus(\n                activeSubscriptions = state.activeSubscriptions,\n                hasActiveSubscription = state.hasActiveSubscription,\n                viewModel = viewModel\n            )\n        }\n        \n        // Subscription Plans Header\n        item {\n            Text(\n                "Choose Your Plan",\n                style = MaterialTheme.typography.headlineSmall,\n                modifier = Modifier.padding(vertical = 8.dp)\n            )\n        }\n        \n        // Subscription Tiers\n        groupedSubs.forEach { (tier, subscriptions) ->\n            item {\n                SubscriptionTierSection(\n                    tier = tier,\n                    subscriptions = subscriptions,\n                    activeSubscriptions = state.activeSubscriptions,\n                    hasActiveSubscription = state.hasActiveSubscription,\n                    viewModel = viewModel\n                )\n            }\n        }\n    }\n}\n\n@Composable\nfun CurrentSubscriptionStatus(\n    activeSubscriptions: List<ActiveSubscription>,\n    hasActiveSubscription: Boolean,\n    viewModel: SubscriptionStoreViewModel\n) {\n    Card(\n        modifier = Modifier.fillMaxWidth(),\n        colors = CardDefaults.cardColors(\n            containerColor = if (!hasActiveSubscription)\n                MaterialTheme.colorScheme.surfaceVariant\n            else\n                Color(0xFF4CAF50).copy(alpha = 0.1f)\n        )\n    ) {\n        Row(\n            modifier = Modifier.padding(16.dp),\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            Icon(\n                imageVector = if (!hasActiveSubscription)\n                    Icons.Default.Info\n                else\n                    Icons.Default.CheckCircle,\n                contentDescription = null,\n                tint = if (!hasActiveSubscription)\n                    MaterialTheme.colorScheme.onSurfaceVariant\n                else\n                    Color(0xFF4CAF50)\n            )\n            Spacer(modifier = Modifier.width(12.dp))\n            Column {\n                Text(\n                    text = if (!hasActiveSubscription)\n                        "No active subscriptions"\n                    else\n                        "Active Subscriptions",\n                    style = MaterialTheme.typography.titleMedium,\n                    fontWeight = FontWeight.Bold\n                )\n                \n                activeSubscriptions.forEach { sub ->\n                    Column {\n                        Text(\n                            text = "${viewModel.getSubscriptionTier(sub.productId)} ${viewModel.getSubscriptionPeriod(sub.productId)}",\n                            style = MaterialTheme.typography.bodyMedium,\n                            color = Color(0xFF4CAF50)\n                        )\n                        \n                        // Show expiration information\n                        sub.expirationDateIOS?.let { expDate ->\n                            val expirationDate = Instant.fromEpochMilliseconds(expDate)\n                            Text(\n                                text = "Expires: ${expirationDate.toLocalDateTime(TimeZone.currentSystemDefault()).date}",\n                                style = MaterialTheme.typography.bodySmall,\n                                color = MaterialTheme.colorScheme.onSurfaceVariant\n                            )\n                        }\n                        \n                        // Show environment (iOS)\n                        sub.environmentIOS?.let { env ->\n                            if (env == "Sandbox") {\n                                Text(\n                                    text = "\ud83e\uddea Sandbox",\n                                    style = MaterialTheme.typography.bodySmall,\n                                    color = Color(0xFFFF9800)\n                                )\n                            }\n                        }\n                        \n                        // Show expiration warning\n                        if (sub.willExpireSoon == true) {\n                            Text(\n                                text = "\u26a0\ufe0f Expires soon",\n                                style = MaterialTheme.typography.bodySmall,\n                                color = Color(0xFFFF5722)\n                            )\n                        }\n                        \n                        // Show auto-renewal status (Android)\n                        sub.autoRenewingAndroid?.let { autoRenew ->\n                            Text(\n                                text = if (autoRenew) "\ud83d\udd04 Auto-renewing" else "\u23f8\ufe0f Will not renew",\n                                style = MaterialTheme.typography.bodySmall,\n                                color = if (autoRenew) Color(0xFF4CAF50) else Color(0xFFFF5722)\n                            )\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun SubscriptionTierSection(\n    tier: String,\n    subscriptions: List<Product>,\n    activeSubscriptions: List<ActiveSubscription>,\n    hasActiveSubscription: Boolean,\n    viewModel: SubscriptionStoreViewModel\n) {\n    val tierColor = viewModel.getTierColor(tier)\n    \n    Card(\n        modifier = Modifier.fillMaxWidth(),\n        colors = CardDefaults.cardColors()\n    ) {\n        Column {\n            // Tier Header\n            Surface(\n                modifier = Modifier.fillMaxWidth(),\n                color = tierColor.copy(alpha = 0.1f)\n            ) {\n                Text(\n                    text = tier,\n                    modifier = Modifier.padding(16.dp),\n                    style = MaterialTheme.typography.titleLarge,\n                    fontWeight = FontWeight.Bold,\n                    color = tierColor\n                )\n            }\n            \n            // Subscription Options\n            subscriptions.forEach { subscription ->\n                SubscriptionTile(\n                    subscription = subscription,\n                    isActive = activeSubscriptions.any { \n                        it.productId == subscription.productId \n                    },\n                    tierColor = tierColor,\n                    onSubscribe = { viewModel.requestSubscription(subscription.productId) }\n                )\n                \n                if (subscription != subscriptions.last()) {\n                    Divider()\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun SubscriptionTile(\n    subscription: Product,\n    isActive: Boolean,\n    tierColor: Color,\n    onSubscribe: () -> Unit\n) {\n    ListItem(\n        headlineContent = {\n            Text(subscription.title)\n        },\n        supportingContent = {\n            subscription.description?.let { Text(it) }\n        },\n        trailingContent = {\n            if (isActive) {\n                Surface(\n                    shape = MaterialTheme.shapes.small,\n                    color = Color(0xFF4CAF50),\n                    contentColor = Color.White\n                ) {\n                    Text(\n                        text = "ACTIVE",\n                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp),\n                        style = MaterialTheme.typography.labelSmall,\n                        fontWeight = FontWeight.Bold\n                    )\n                }\n            } else {\n                Button(\n                    onClick = onSubscribe,\n                    colors = ButtonDefaults.buttonColors(\n                        containerColor = tierColor\n                    )\n                ) {\n                    Text(subscription.price)\n                }\n            }\n        }\n    )\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"key-features-explained",children:"Key Features Explained"}),"\n",(0,t.jsx)(e.h3,{id:"1-subscription-grouping",children:"1. Subscription Grouping"}),"\n",(0,t.jsx)(e.p,{children:"The store groups subscriptions by tier (Premium, Pro) for better organization:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"val groupedSubs = state.subscriptions.groupBy { \n    viewModel.getSubscriptionTier(it.productId) \n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-status-display",children:"2. Status Display"}),"\n",(0,t.jsx)(e.p,{children:"Shows current subscription status prominently:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"@Composable\nfun CurrentSubscriptionStatus(\n    activeSubscriptions: List<Purchase>,\n    viewModel: SubscriptionStoreViewModel\n) {\n    // Visual indication of active subscriptions\n    // Different colors and icons for active vs inactive\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-visual-hierarchy",children:"3. Visual Hierarchy"}),"\n",(0,t.jsx)(e.p,{children:"Different colors and styling for different subscription tiers:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'fun getTierColor(tier: String): Color {\n    return when (tier.lowercase()) {\n        "premium" -> Color(0xFFFFA726) // Orange\n        "pro" -> Color(0xFF9C27B0) // Purple\n        else -> Color(0xFF2196F3) // Blue\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"4-android-subscription-offers",children:"4. Android Subscription Offers"}),"\n",(0,t.jsx)(e.p,{children:"Handles Android subscription offers properly:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"if (KmpIAP.getCurrentPlatform() == IapPlatform.ANDROID) {\n    val offers = product?.subscriptionOffers\n    if (!offers.isNullOrEmpty()) {\n        KmpIAP.requestSubscription(\n            sku = productId,\n            subscriptionOffers = listOf(\n                SubscriptionOfferAndroid(\n                    sku = productId,\n                    offerToken = offers.first().offerToken\n                )\n            )\n        )\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"best-practices-implemented",children:"Best Practices Implemented"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Error Handling"}),": Comprehensive error handling with user-friendly messages"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Loading States"}),": Shows loading indicators during async operations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Purchase Verification"}),": Placeholder for server-side verification"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Transaction Completion"}),": Proper handling of iOS and Android differences"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Restore Functionality"}),": Easy way for users to restore purchases"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Status Display"}),": Clear indication of active subscriptions with detailed information"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"StateFlow Usage"}),": Reactive state management with Kotlin StateFlow"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Enhanced Subscription Management"}),": Uses new ",(0,t.jsx)(e.code,{children:"getActiveSubscriptions()"})," and ",(0,t.jsx)(e.code,{children:"hasActiveSubscriptions()"})," APIs"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Platform-Specific Details"}),": Shows expiration dates (iOS), auto-renewal status (Android), and environment info"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"enhanced-subscription-management-features",children:"Enhanced Subscription Management Features"}),"\n",(0,t.jsx)(e.h3,{id:"using-new-activesubscription-apis",children:"Using New ActiveSubscription APIs"}),"\n",(0,t.jsx)(e.p,{children:"The example now uses the enhanced subscription APIs for more detailed information:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'// Check if user has any active subscriptions (quick check)\nval hasActiveSubscription = kmpIapInstance.hasActiveSubscriptions(subscriptionIds)\n\n// Get detailed subscription information\nval activeSubscriptions = kmpIapInstance.getActiveSubscriptions(subscriptionIds)\n\nactiveSubscriptions.forEach { subscription ->\n    println("Active subscription: ${subscription.productId}")\n    \n    // iOS-specific information\n    subscription.expirationDateIOS?.let { expDate ->\n        val expirationDate = Instant.fromEpochMilliseconds(expDate)\n        println("  Expires: $expirationDate")\n    }\n    subscription.environmentIOS?.let { env ->\n        println("  Environment: $env") // "Sandbox" or "Production"\n    }\n    subscription.daysUntilExpirationIOS?.let { days ->\n        println("  Days until expiration: $days")\n    }\n    \n    // Android-specific information\n    subscription.autoRenewingAndroid?.let { autoRenew ->\n        println("  Auto-renewing: $autoRenew")\n    }\n    \n    // Cross-platform warnings\n    if (subscription.willExpireSoon == true) {\n        println("  \u26a0\ufe0f This subscription will expire soon!")\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"platform-specific-subscription-details",children:"Platform-Specific Subscription Details"}),"\n",(0,t.jsx)(e.h4,{id:"ios-features",children:"iOS Features"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Expiration Date"}),": Exact timestamp when subscription expires"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Environment Detection"}),": Automatically detects Sandbox vs Production"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Days Until Expiration"}),": Calculated remaining days"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Expiration Warnings"}),": ",(0,t.jsx)(e.code,{children:"willExpireSoon"})," flag for subscriptions expiring within 7 days"]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"android-features",children:"Android Features"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Auto-Renewal Status"}),": Shows if subscription will automatically renew"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Grace Period Support"}),": Can be extended with server-side validation"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"visual-subscription-status",children:"Visual Subscription Status"}),"\n",(0,t.jsx)(e.p,{children:"The UI now shows rich subscription information:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:'// Show expiration information\nsub.expirationDateIOS?.let { expDate ->\n    val expirationDate = Instant.fromEpochMilliseconds(expDate)\n    Text(\n        text = "Expires: ${expirationDate.toLocalDateTime(TimeZone.currentSystemDefault()).date}",\n        style = MaterialTheme.typography.bodySmall,\n        color = MaterialTheme.colorScheme.onSurfaceVariant\n    )\n}\n\n// Show environment (iOS)\nsub.environmentIOS?.let { env ->\n    if (env == "Sandbox") {\n        Text(\n            text = "\ud83e\uddea Sandbox",\n            style = MaterialTheme.typography.bodySmall,\n            color = Color(0xFFFF9800)\n        )\n    }\n}\n\n// Show expiration warning\nif (sub.willExpireSoon == true) {\n    Text(\n        text = "\u26a0\ufe0f Expires soon",\n        style = MaterialTheme.typography.bodySmall,\n        color = Color(0xFFFF5722)\n    )\n}\n\n// Show auto-renewal status (Android)\nsub.autoRenewingAndroid?.let { autoRenew ->\n    Text(\n        text = if (autoRenew) "\ud83d\udd04 Auto-renewing" else "\u23f8\ufe0f Will not renew",\n        style = MaterialTheme.typography.bodySmall,\n        color = if (autoRenew) Color(0xFF4CAF50) else Color(0xFFFF5722)\n    )\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"legacy-subscription-status-check",children:"Legacy Subscription Status Check"}),"\n",(0,t.jsx)(e.p,{children:"For backward compatibility, you can still use the basic check:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"private fun isSubscriptionActive(purchase: Purchase): Boolean {\n    // In production, check actual expiration date\n    return when (purchase.purchaseState) {\n        PurchaseState.PURCHASED -> true\n        PurchaseState.PENDING -> true // Show as active during pending\n        else -> false\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"handling-grace-periods",children:"Handling Grace Periods"}),"\n",(0,t.jsx)(e.p,{children:"For production apps, implement grace period handling:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"private fun checkSubscriptionWithGracePeriod(purchase: Purchase): SubscriptionStatus {\n    val expirationDate = purchase.expirationDate ?: return SubscriptionStatus.EXPIRED\n    val now = Clock.System.now()\n    \n    return when {\n        now < expirationDate -> SubscriptionStatus.ACTIVE\n        now < expirationDate.plus(3.days) -> SubscriptionStatus.IN_GRACE_PERIOD\n        else -> SubscriptionStatus.EXPIRED\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"testing-considerations",children:"Testing Considerations"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Test with different subscription tiers"}),"\n",(0,t.jsx)(e.li,{children:"Test restoration on device reinstall"}),"\n",(0,t.jsx)(e.li,{children:"Test subscription expiration handling"}),"\n",(0,t.jsx)(e.li,{children:"Test grace period scenarios"}),"\n",(0,t.jsx)(e.li,{children:"Test with different payment methods"}),"\n",(0,t.jsx)(e.li,{children:"Test subscription upgrades/downgrades"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"platform-specific-features",children:"Platform-Specific Features"}),"\n",(0,t.jsx)(e.h3,{id:"ios-promotional-offers",children:"iOS Promotional Offers"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"// iOS specific - check for promotional offers\nif (KmpIAP.getCurrentPlatform() == IapPlatform.IOS) {\n    viewModelScope.launch {\n        KmpIAP.promotedProductsIOS.collectLatest { promotedProducts ->\n            // Handle App Store promoted products\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"android-subscription-management",children:"Android Subscription Management"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-kotlin",children:"// Android specific - deep link to subscription management\nsuspend fun openSubscriptionManagement(productId: String) {\n    if (KmpIAP.getCurrentPlatform() == IapPlatform.ANDROID) {\n        KmpIAP.deepLinkToSubscriptionsAndroid(productId)\n    }\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"This example provides a solid foundation for a subscription-based app with multiple tiers and billing periods using Kotlin Multiplatform."})]})}function d(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(u,{...n})}):u(n)}},5159:(n,e,i)=>{i.d(e,{A:()=>s});i(6540);var t=i(6025),r=i(7856),o=i(4848);function s({className:n="iapkit-banner",style:e}){const i=(0,t.A)("/img/iapkit-banner.gif");return(0,o.jsx)("div",{className:n,style:e,children:(0,o.jsx)("a",{href:r.V,target:"_blank",rel:"noopener noreferrer",onClick:async()=>{try{await fetch(r.I,{method:"POST",mode:"no-cors"})}catch(n){console.error("Failed to track banner click:",n)}},style:{display:"block",textAlign:"center",marginBottom:"20px",textDecoration:"none",cursor:"pointer"},children:(0,o.jsx)("img",{src:i,alt:"IAPKit - In-App Purchase Made Simple",style:{height:"auto",borderRadius:"8px",objectFit:"contain"}})})})}},7856:(n,e,i)=>{i.d(e,{I:()=>r,V:()=>t});const t="https://iapkit.com",r="https://www.hyo.dev/api/ad-banner/cmjf0l20n0002249hjrwmgob3"},8453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>a});var t=i(6540);const r={},o=t.createContext(r);function s(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);